<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>魏龙龙的个人博客</title>
  
  <subtitle>魏龙龙的个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://weilonglong.top/"/>
  <updated>2020-08-24T12:49:10.092Z</updated>
  <id>http://weilonglong.top/</id>
  
  <author>
    <name>魏龙龙</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速开启本地服务</title>
    <link href="http://weilonglong.top/2020/08/22/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%90%AF%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1/"/>
    <id>http://weilonglong.top/2020/08/22/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%90%AF%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-08-22T07:18:56.000Z</published>
    <updated>2020-08-24T12:49:10.092Z</updated>
    
    <content type="html"><![CDATA[<p>在本地开发时,写html页面时经常会遇到需要开启本地服务,在其余电脑进行调试，或者进行手机查看效果的情况。<br>在这介绍两种。</p><h3 id="利用express-generator快速开启本地服务"><a href="#利用express-generator快速开启本地服务" class="headerlink" title="利用express-generator快速开启本地服务"></a>利用express-generator快速开启本地服务</h3><p>全局安装express-generator<br><code>npm i express-generator -g</code><br>创建项目<br><code>express  demo -e</code><br>-e的含义是使用ejs模板<br><code>cd demo</code><br><code>npm install</code><br>将文件放到public文件夹下,执行<code>npm run dev</code>默认3000端口即可访问</p><h3 id="在Vscode中安装Live-Server插件"><a href="#在Vscode中安装Live-Server插件" class="headerlink" title="在Vscode中安装Live Server插件"></a>在Vscode中安装Live Server插件</h3><p>在Vscode中搜索Live Server进行安装，将工作文件夹拖到工作区，或文件打开文件夹。右键点击Open with live server即可访问5500端口。<br>如在上次已经打开过项目，再进行开启项目时，开启不起来，右键点击stop live serve,重新开启即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本地开发时,写html页面时经常会遇到需要开启本地服务,在其余电脑进行调试，或者进行手机查看效果的情况。&lt;br&gt;在这介绍两种。&lt;/p&gt;
&lt;h3 id=&quot;利用express-generator快速开启本地服务&quot;&gt;&lt;a href=&quot;#利用express-generator快速
      
    
    </summary>
    
    
    
      <category term="快速开启本地服务" scheme="http://weilonglong.top/tags/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%90%AF%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Socket.Io与express在http请求中发送消息初体验</title>
    <link href="http://weilonglong.top/2020/08/22/Socket-Io%E4%B8%8Eexpress%E5%9C%A8http%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://weilonglong.top/2020/08/22/Socket-Io%E4%B8%8Eexpress%E5%9C%A8http%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-08-22T06:15:01.000Z</published>
    <updated>2020-08-24T12:49:10.089Z</updated>
    
    <content type="html"><![CDATA[<p>网上基本出现的大多都是这种简单写法,并没有做一个深入的写，怎么进行在http请求中进行websocket的发送消息，近日，自己因为需求，因为不熟悉，走了很多弯路，故自己这次进行一下记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;); </span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">var server &#x3D; require(&#39;http&#39;).createServer(app);</span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;)(server);</span><br><span class="line"></span><br><span class="line">app.use(&#39;&#x2F;&#39;, express.static(__dirname + &#39;&#x2F;public&#39;)); </span><br><span class="line"></span><br><span class="line">server.listen(80);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;socket部分</span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">    &#x2F;&#x2F;接收并处理客户端的hi事件</span><br><span class="line">    socket.on(&#39;hi&#39;, function(data) &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;触发客户端事件c_hi</span><br><span class="line">        socket.emit(&#39;c_hi&#39;,&#39;hello too!&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;断开事件</span><br><span class="line">    socket.on(&#39;disconnect&#39;, function(data) &#123;</span><br><span class="line">    console.log(&#39;断开&#39;,data)</span><br><span class="line">        socket.emit(&#39;c_leave&#39;,&#39;离开&#39;);</span><br><span class="line">        &#x2F;&#x2F;socket.broadcast用于向整个网络广播(除自己之外)</span><br><span class="line">        &#x2F;&#x2F;socket.broadcast.emit(&#39;c_leave&#39;,&#39;某某人离开了&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种没有写怎么在http请求中怎么进行处理websocket消息。<br>基于Sequelize-cli生成的框架，其是又bin/www文件进行启动监听的，我们不进行修改，仍由www文件进行启动监听，但是app.js需<br>要修改。<br>app.js中新增以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;)(server);</span><br><span class="line"></span><br><span class="line">app.use(function(req, res, next)&#123;  </span><br><span class="line">  res.io &#x3D; io;  </span><br><span class="line">  next();  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">    &#x2F;&#x2F;接收并处理客户端的hi事件</span><br><span class="line">    socket.on(&#39;hi&#39;, function(data) &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;触发客户端事件c_hi</span><br><span class="line">        socket.emit(&#39;c_hi&#39;,&#39;hello too!&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;断开事件</span><br><span class="line">    socket.on(&#39;disconnect&#39;, function(data) &#123;</span><br><span class="line">      console.log(&#39;断开&#39;,data)</span><br><span class="line">        socket.emit(&#39;c_leave&#39;,&#39;离开&#39;);</span><br><span class="line">        &#x2F;&#x2F;socket.broadcast用于向整个网络广播(除自己之外)</span><br><span class="line">        &#x2F;&#x2F;socket.broadcast.emit(&#39;c_leave&#39;,&#39;某某人离开了&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">app.server&#x3D;server</span><br><span class="line">module.exports &#x3D; app;</span><br></pre></td></tr></table></figure><p>www文件进行删除相应的http，以及http.createServe()，并将所有的server更换为app.serve</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var app &#x3D; require(&#39;..&#x2F;app&#39;);</span><br><span class="line">var debug &#x3D; require(&#39;debug&#39;)(&#39;app:server&#39;);</span><br><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Get port from environment and store in Express.</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">var port &#x3D; normalizePort(process.env.PORT || &#39;5000&#39;);</span><br><span class="line">app.set(&#39;port&#39;, port);</span><br><span class="line">&#x2F;**</span><br><span class="line">* Create HTTP server.</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.server.listen(port);</span><br><span class="line">app.server.on(&#39;error&#39;, onError);</span><br><span class="line">app.server.on(&#39;listening&#39;, onListening);</span><br></pre></td></tr></table></figure><p>这样在router/index.js中即可进行对房间中的连接进行发送消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#39;&#x2F;:id&#39;, function (req, res, next) &#123;</span><br><span class="line">  res.io.emit(&#39;c_hi&#39;,&#123;code:1,data:&#39;data&#39;&#125;)</span><br><span class="line">  res.send(&#123;code:1,data:&#39;data&#39;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;ul id&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    </span><br><span class="line">    socket &#x3D; io.connect(&#39;ws:&#x2F;&#x2F;127.0.0.1:5000&#39;);</span><br><span class="line"></span><br><span class="line">    socket.emit(&quot;message&quot;, &#123;&quot;name&quot; : navigator.userAgent, room:&#39;1&#39;, &quot;msg&quot; : &quot;hello world&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    socket.on(&quot;message&quot;, function(obj) &#123;</span><br><span class="line"></span><br><span class="line">      console.log(obj);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>大功告成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上基本出现的大多都是这种简单写法,并没有做一个深入的写，怎么进行在http请求中进行websocket的发送消息，近日，自己因为需求，因为不熟悉，走了很多弯路，故自己这次进行一下记录。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
    
      <category term="Express" scheme="http://weilonglong.top/tags/Express/"/>
    
      <category term="Socket.Io" scheme="http://weilonglong.top/tags/Socket-Io/"/>
    
      <category term="Node.js" scheme="http://weilonglong.top/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>border-radius的简写</title>
    <link href="http://weilonglong.top/2020/08/19/border-radius%E7%9A%84%E7%AE%80%E5%86%99/"/>
    <id>http://weilonglong.top/2020/08/19/border-radius%E7%9A%84%E7%AE%80%E5%86%99/</id>
    <published>2020-08-19T04:20:53.000Z</published>
    <updated>2020-08-24T12:49:10.091Z</updated>
    
    <content type="html"><![CDATA[<p>border-radius一般在实际使用的时候一般是画小圆角或者弧度，弧度花的话一般也是四个角一起画，两个角画会响应减少，两个角的弧度不一致更在实际的需求会少很多,就算一个角有特殊需求，也可以单独进行设置。</p><p>border-radius在实际的使用中还是很多的，在最一开始学的时候记住了简写，没有深入的学习,虽然会写，但是复杂的带/的没弄懂什么意思，今天学习一下。<br><code>border-radius:2px;</code><br>等价于的语句是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-top-left-radius:2px 2px;</span><br><span class="line">border-top-right-raduis:2px 2px;</span><br><span class="line">border-bottom-right-raduis:2px 2px;</span><br><span class="line">border-bottom-left-radius:2px 2px;</span><br></pre></td></tr></table></figure><p>为什么这两个是等价的呢。<br>在菜鸟教程文档中,border-radius的标准简写是这样的<br><code>border-radius: 1-4 length|% / 1-4 length|%;</code><br><code>注意: 每个半径的四个值的顺序是：左上角，右上角，右下角，左下角。如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的。</code></p><p>归根于这句话。<br>之前的那种写法都是省略过的，如果补全是这样的。<br><code>border-radius:2px 2px 2px 2px/2px 2px 2px 2px;</code></p><p>这里边有一个重点，即如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的；如果你使用省略写法的话,单独一个角没有圆角时，必须记得设置为0，那么其会与之相匹配的角一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 2em 1em 4em &#x2F; 0.5em 3em;</span><br><span class="line"></span><br><span class="line">is equivalent to:</span><br><span class="line"></span><br><span class="line">border-top-left-radius: 2em 0.5em;</span><br><span class="line">border-top-right-radius: 1em 3em;</span><br><span class="line">border-bottom-right-radius: 4em 0.5em;</span><br><span class="line">border-bottom-left-radius: 1em 3em;</span><br></pre></td></tr></table></figure><p>在上边的”/“前面是圆角的水平半径，”/“后面是圆角的垂直半径。<br>这样也就理解了上边的等价是什么意思。<br>其补充完是这样的<br><code>border-radius: 2em 1em 4em 1em/ 0.5em 3em 0.5em 3em;</code><br>这样再去看其相等就一眼看明白了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;border-radius一般在实际使用的时候一般是画小圆角或者弧度，弧度花的话一般也是四个角一起画，两个角画会响应减少，两个角的弧度不一致更在实际的需求会少很多,就算一个角有特殊需求，也可以单独进行设置。&lt;/p&gt;
&lt;p&gt;border-radius在实际的使用中还是很多的，
      
    
    </summary>
    
    
    
      <category term="css" scheme="http://weilonglong.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端无痛刷新token</title>
    <link href="http://weilonglong.top/2020/08/17/%E5%89%8D%E7%AB%AF%E6%97%A0%E7%97%9B%E5%88%B7%E6%96%B0token/"/>
    <id>http://weilonglong.top/2020/08/17/%E5%89%8D%E7%AB%AF%E6%97%A0%E7%97%9B%E5%88%B7%E6%96%B0token/</id>
    <published>2020-08-17T12:50:41.000Z</published>
    <updated>2020-08-24T12:49:10.092Z</updated>
    
    <content type="html"><![CDATA[<p>两种方案，第一种记录登录时间，根据后台设置的token过期时间，进行在时间内请求更换token<br>第二种利用axios的拦截，在返回token过期时，那么token去更换token，再用新的token去请求数据。<br>第二种，上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import &#123; Message &#125; from &#39;element-ui&#39;</span><br><span class="line">import store from &#39;@&#x2F;store&#39;</span><br><span class="line">import &#123; getToken &#125; from &#39;@&#x2F;utils&#x2F;auth&#39;</span><br><span class="line"></span><br><span class="line">var isRefreshing &#x3D; false</span><br><span class="line">var requests &#x3D; []</span><br><span class="line">&#x2F;&#x2F; create an axios instance</span><br><span class="line">const service &#x3D; axios.create(&#123;</span><br><span class="line">  baseURL: process.env.VUE_APP_BASE_API,</span><br><span class="line">  timeout: 5000 &#x2F;&#x2F; request timeout</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; request interceptor</span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  config &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (store.getters.token) &#123;</span><br><span class="line">      config.headers[&#39;Authorization&#39;] &#x3D; &#39;Bearer &#39; + getToken()</span><br><span class="line">    &#125;</span><br><span class="line">    return config</span><br><span class="line">  &#125;,</span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line">    console.log(error) &#x2F;&#x2F; for debug</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; response interceptor</span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * If you want to get http information such as headers or status</span><br><span class="line">   * Please return  response &#x3D;&gt; response</span><br><span class="line">  *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Determine the request status by custom code</span><br><span class="line">   * Here is just an example</span><br><span class="line">   * You can also judge the status by HTTP Status Code</span><br><span class="line">   *&#x2F;</span><br><span class="line">  response &#x3D;&gt; &#123;</span><br><span class="line">    const res &#x3D; response.data</span><br><span class="line">    console.log(res, &#39;response.data&#39;)</span><br><span class="line">    if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">      return res</span><br><span class="line">    &#125; else if (res.code &#x3D;&#x3D;&#x3D; 50008 || res.code &#x3D;&#x3D;&#x3D; 50012 || res.code &#x3D;&#x3D;&#x3D; 50014) &#123;</span><br><span class="line">      const config &#x3D; response.config</span><br><span class="line">      if (!isRefreshing) &#123;</span><br><span class="line">        isRefreshing &#x3D; true</span><br><span class="line">        return store.dispatch(&#39;user&#x2F;resetToken&#39;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">          const token &#x3D; res</span><br><span class="line">          config.headers[&#39;Authorization&#39;] &#x3D; token</span><br><span class="line">          config.baseURL &#x3D; &#39;&#39; &#x2F;&#x2F; url已经带上了&#x2F;api，避免出现&#x2F;api&#x2F;api的情况</span><br><span class="line">          requests.forEach(item &#x3D;&gt; item(token))</span><br><span class="line">          requests &#x3D; []</span><br><span class="line">          &#x2F;&#x2F; 重试当前请求并返回promise</span><br><span class="line">          &#x2F;&#x2F; console.log(service(config), &#39;service(config)&#39;)</span><br><span class="line">          return service(config)</span><br><span class="line">        &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">          console.log(err)</span><br><span class="line">          &#x2F;&#x2F; console.error(&#39;refreshtoken error &#x3D;&gt;&#39;, res)</span><br><span class="line">          &#x2F;&#x2F; 刷新token失败，神仙也救不了了，跳转到首页重新登录吧</span><br><span class="line">          window.location.href &#x3D; &#39;&#x2F;&#39;</span><br><span class="line">        &#125;).finally(() &#x3D;&gt; &#123;</span><br><span class="line">          isRefreshing &#x3D; false</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span><br><span class="line">          requests.push((token) &#x3D;&gt; &#123;</span><br><span class="line">            config.baseURL &#x3D; &#39;&#39;</span><br><span class="line">            config.headers[&#39;Authorization&#39;] &#x3D; token</span><br><span class="line">            resolve(service(config))</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Message(&#123;</span><br><span class="line">        message: res.message,</span><br><span class="line">        type: &#39;error&#39;,</span><br><span class="line">        duration: 5 * 1000</span><br><span class="line">      &#125;)</span><br><span class="line">      return Promise.reject(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default service</span><br></pre></td></tr></table></figure><p>思路,<br>当后端返回无权限时，将请求先保存下来，return一个Promise,利用Promise去刷新token,当请求token成功,拿着心得token,拿着存的config，去再次请求，成功后reslove()<br>这时带来了一个问题，就是当多次请求时,会多次refresh_token<br>设置一个状态值，用于记录是否正在刷新token。<br>如果正在刷新token，将其利用Promise，将其封装为一个函数,内部自动调用resolve,存入一个数组，等到刷新token后，执行存入的函数,执行resolve(),然后依次来再次请求数据，返回正确的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 我们先看一下，定义fn1</span><br><span class="line">function fn1 () &#123;</span><br><span class="line">    console.log(&#39;执行fn1&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行fn1,只需后面加个括号</span><br><span class="line">fn1()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回归到我们request数组中，每一项其实存的就是一个类似fn1的一个函数</span><br><span class="line">const fn2 &#x3D; (token) &#x3D;&gt; &#123;</span><br><span class="line">    config.headers[&#39;X-Token&#39;] &#x3D; token</span><br><span class="line">    resolve(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们要执行fn2，也只需在后面加个括号就可以了</span><br><span class="line">fn2()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于requests是一个数组，所以我们想遍历执行里面的所有的项，所以用上了forEach</span><br><span class="line">requests.forEach(fn &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 执行fn</span><br><span class="line">  fn()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两种方案，第一种记录登录时间，根据后台设置的token过期时间，进行在时间内请求更换token&lt;br&gt;第二种利用axios的拦截，在返回token过期时，那么token去更换token，再用新的token去请求数据。&lt;br&gt;第二种，上代码&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://weilonglong.top/tags/Vue/"/>
    
      <category term="token" scheme="http://weilonglong.top/tags/token/"/>
    
      <category term="Axios" scheme="http://weilonglong.top/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>长时间无操作退出登录，返回登录页</title>
    <link href="http://weilonglong.top/2020/08/16/%E9%95%BF%E6%97%B6%E9%97%B4%E6%97%A0%E6%93%8D%E4%BD%9C%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%99%BB%E5%BD%95%E9%A1%B5/"/>
    <id>http://weilonglong.top/2020/08/16/%E9%95%BF%E6%97%B6%E9%97%B4%E6%97%A0%E6%93%8D%E4%BD%9C%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%99%BB%E5%BD%95%E9%A1%B5/</id>
    <published>2020-08-16T12:53:29.000Z</published>
    <updated>2020-08-24T12:49:10.093Z</updated>
    
    <content type="html"><![CDATA[<p>先上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      interval: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    localStorage.setItem(&#39;lastTime&#39;, new Date().getTime())</span><br><span class="line">    this.addOn()</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    window.clearInterval(this.interval)</span><br><span class="line">&#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line">    addOn() &#123;</span><br><span class="line">      var lastTime &#x3D; new Date().getTime()</span><br><span class="line">      var currentTime &#x3D; new Date().getTime()</span><br><span class="line">      var timeOut &#x3D; 30 * 60 * 1000; &#x2F;&#x2F; 设置超时时间： 30分</span><br><span class="line"></span><br><span class="line">      window.document.onmousedown &#x3D; function() &#123;</span><br><span class="line">        localStorage.setItem(&#39;lastTime&#39;, new Date().getTime())</span><br><span class="line">      &#125;</span><br><span class="line">      function checkTimeout() &#123;</span><br><span class="line">        currentTime &#x3D; new Date().getTime() &#x2F;&#x2F; 更新当前时间</span><br><span class="line">        lastTime &#x3D; localStorage.getItem(&#39;lastTime&#39;)</span><br><span class="line">        if (currentTime - lastTime &gt; timeOut) &#123; &#x2F;&#x2F; 判断是否超时</span><br><span class="line">          var url &#x3D; window.location.href</span><br><span class="line">          var newUrl &#x3D; url.match(&#x2F;(\S*)#&#x2F;)[1]</span><br><span class="line">          removeToken()</span><br><span class="line">          window.open(newUrl + &#39;#&#x2F;login&#39;, &#39;_self&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;* 定时器 间隔30秒检测是否长时间未操作页面 *&#x2F;</span><br><span class="line">      this.interval &#x3D; window.setInterval(checkTimeout, 30*1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该页面时Layout布局中的,login页面是不引用的,<br>思路,在该页面mounted时设置一个时间，增加一个监听事件<br>每按下鼠标时，更新一次时间<br>每隔30s判断一次上次按下鼠标据现在时间间隔,如果超过了30分钟，清空定时器<br>清空token,将其返回到登录页面。<br>那么beforeDestroy()中是为了人为操作退出登录，然后清空定时器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先上代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://weilonglong.top/tags/Vue/"/>
    
      <category term="JaveScript" scheme="http://weilonglong.top/tags/JaveScript/"/>
    
  </entry>
  
  <entry>
    <title>Sequelize-cli中新增列和删除列</title>
    <link href="http://weilonglong.top/2020/08/13/Sequelize-cli%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%88%97%E5%92%8C%E5%88%A0%E9%99%A4%E5%88%97/"/>
    <id>http://weilonglong.top/2020/08/13/Sequelize-cli%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%88%97%E5%92%8C%E5%88%A0%E9%99%A4%E5%88%97/</id>
    <published>2020-08-13T14:37:41.000Z</published>
    <updated>2020-08-13T14:38:42.113Z</updated>
    
    <content type="html"><![CDATA[<p>之前处于来发的时候，都是将数据表删除，将Sequlize迁移记录表中的记录进行删除，然后进行运行迁移，生成数据表，现在项目已经跑起来了，不能再这样操作了，否则会造成数据丢失。故寻找执行其迁移文件的增加列方法。<br>第一步执行命令<br><code>sequelize migration：create --name name_of_your_migration</code><br>或者自己手动新建.js文件<br>进行修改js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">up: (queryInterface, Sequelize) &#x3D;&gt; &#123;</span><br><span class="line">    return queryInterface.addColumn(</span><br><span class="line">        &#39;Storagelists&#39;,  &#x2F;&#x2F; 表名</span><br><span class="line">        &#39;name&#39;, &#x2F;&#x2F; 列名</span><br><span class="line">        Sequelize.TEXT &#x2F;&#x2F; 数据类型</span><br><span class="line">    );</span><br><span class="line">&#125;,</span><br><span class="line">down: (queryInterface, Sequelize) &#x3D;&gt; &#123;</span><br><span class="line">    return queryInterface.removeColumn(</span><br><span class="line">        &#39;Storagelists&#39;, &#x2F;&#x2F; 要执行的表名</span><br><span class="line">        &#39;deletename&#39; &#x2F;&#x2F; 删除的列名</span><br><span class="line">    ); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行迁移命令<br><code>sequleize db:migrate</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前处于来发的时候，都是将数据表删除，将Sequlize迁移记录表中的记录进行删除，然后进行运行迁移，生成数据表，现在项目已经跑起来了，不能再这样操作了，否则会造成数据丢失。故寻找执行其迁移文件的增加列方法。&lt;br&gt;第一步执行命令&lt;br&gt;&lt;code&gt;sequelize mi
      
    
    </summary>
    
    
    
      <category term="Sequelize-cli" scheme="http://weilonglong.top/tags/Sequelize-cli/"/>
    
  </entry>
  
  <entry>
    <title>Vue-cli项目使用CDN优化Element-ui打包体积太大问题</title>
    <link href="http://weilonglong.top/2020/08/11/Vue-cli%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8MDN%E5%8A%A0%E9%80%9FElement-ui/"/>
    <id>http://weilonglong.top/2020/08/11/Vue-cli%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8MDN%E5%8A%A0%E9%80%9FElement-ui/</id>
    <published>2020-08-11T09:22:03.000Z</published>
    <updated>2020-08-24T12:49:10.090Z</updated>
    
    <content type="html"><![CDATA[<p>Vue-cli生成的单页面,引入Element-ui后打包后js，css大，服务器带宽小，首屏渲染速度慢，进行优化的方案之一即是MDN加速。<br>在index.html中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;element-ui&#x2F;2.7.2&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>修改main.js,将引入Element以及Use注释删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; import ElementUI from &#39;element-ui&#39;</span><br><span class="line">&#x2F;&#x2F; import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line">&#x2F;&#x2F; Vue.use(ElementUI)</span><br></pre></td></tr></table></figure><p>修改vue.config.js,增加此段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: &#123;</span><br><span class="line">    externals: &#123;</span><br><span class="line">        &#39;vue&#39;: &#39;Vue&#39;,</span><br><span class="line">        &#39;element-ui&#39;: &#39;ELEMENT&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue-cli生成的单页面,引入Element-ui后打包后js，css大，服务器带宽小，首屏渲染速度慢，进行优化的方案之一即是MDN加速。&lt;br&gt;在index.html中写入&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="MDN优化" scheme="http://weilonglong.top/tags/MDN%E4%BC%98%E5%8C%96/"/>
    
      <category term="Element-ui性能优化" scheme="http://weilonglong.top/tags/Element-ui%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>在vue中使用screen-full全屏</title>
    <link href="http://weilonglong.top/2020/08/08/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8screen-full%E5%85%A8%E5%B1%8F/"/>
    <id>http://weilonglong.top/2020/08/08/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8screen-full%E5%85%A8%E5%B1%8F/</id>
    <published>2020-08-08T02:51:27.000Z</published>
    <updated>2020-08-09T14:43:36.560Z</updated>
    
    <content type="html"><![CDATA[<p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save screenfull</span><br></pre></td></tr></table></figure><p>封装为组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;svg-icon :icon-class&#x3D;&quot;isFullscreen?&#39;exit-fullscreen&#39;:&#39;fullscreen&#39;&quot; @click&#x3D;&quot;click&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import screenfull from &#39;screenfull&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">name: &#39;Screenfull&#39;,</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    isFullscreen: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.init()</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    this.destroy()</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    click() &#123;</span><br><span class="line">    if (!screenfull.enabled) &#123;</span><br><span class="line">        this.$message(&#123;</span><br><span class="line">        message: &#39;you browser can not work&#39;,</span><br><span class="line">        type: &#39;warning&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    screenfull.toggle()</span><br><span class="line">    &#125;,</span><br><span class="line">    change() &#123;</span><br><span class="line">    this.isFullscreen &#x3D; screenfull.isFullscreen</span><br><span class="line">    &#125;,</span><br><span class="line">    init() &#123;</span><br><span class="line">    if (screenfull.enabled) &#123;</span><br><span class="line">        screenfull.on(&#39;change&#39;, this.change)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    destroy() &#123;</span><br><span class="line">    if (screenfull.enabled) &#123;</span><br><span class="line">        screenfull.off(&#39;change&#39;, this.change)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.screenfull-svg &#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">cursor: pointer;</span><br><span class="line">fill: #5a5e66;;</span><br><span class="line">width: 20px;</span><br><span class="line">height: 20px;</span><br><span class="line">vertical-align: 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><ul><li>在需要使用的页面中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;screenfull id&#x3D;&quot;screenfull&quot; class&#x3D;&quot;right-menu-item hover-effect&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">import Screenfull from &#39;@&#x2F;components&#x2F;Screenfull&#39;</span><br><span class="line"></span><br><span class="line">components: &#123;</span><br><span class="line">    Screenfull</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://weilonglong.top/tags/Vue/"/>
    
      <category term="screenfull" scheme="http://weilonglong.top/tags/screenfull/"/>
    
  </entry>
  
  <entry>
    <title>使用bat文件快速启动vue项目</title>
    <link href="http://weilonglong.top/2020/08/05/%E4%BD%BF%E7%94%A8bat%E6%96%87%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8vue%E9%A1%B9%E7%9B%AE/"/>
    <id>http://weilonglong.top/2020/08/05/%E4%BD%BF%E7%94%A8bat%E6%96%87%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8vue%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-08-05T02:41:35.000Z</published>
    <updated>2020-08-09T14:43:36.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单项目"><a href="#单项目" class="headerlink" title="单项目"></a>单项目</h3><p>例如需启动”d/vue”下的项目<br>新建run.text,写入以下内容，修改后缀名为.bat,双击运行项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:: nodejs安装目录下的nodevars.bat</span><br><span class="line">set nodevars &#x3D; &quot;C:\Program Files\nodejs\nodevars.bat&quot;</span><br><span class="line">:: 切换到D盘</span><br><span class="line">d:</span><br><span class="line">:: 移动到需要启动的目录</span><br><span class="line">cd vue</span><br><span class="line">:: 启动项目</span><br><span class="line">cmd &#x2F;c %nodevars%&amp;&amp;npm run dev</span><br></pre></td></tr></table></figure><h3 id="可能多项目情况下"><a href="#可能多项目情况下" class="headerlink" title="可能多项目情况下"></a>可能多项目情况下</h3><p>如果在vue文件下有多个项目，可通过输入项目文件夹进行启动<br>例如 “d/vue/project1”,”d/vue/project2”项目,<br>可输入project1或者project2<br>如果运行项目直接回车，或者输入y/Y回车<br>如果只需要node环境，则输入n/N回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set nodevars &#x3D; &quot;C:\Program Files\nodejs\nodevars.bat&quot;</span><br><span class="line">:: 切换到D盘</span><br><span class="line">d:</span><br><span class="line">:: 移动到工作目录</span><br><span class="line">cd vue</span><br><span class="line">:: 中文提示会乱码</span><br><span class="line">echo Run Node.js command Or Npm run dev.</span><br><span class="line">set&#x2F;p option&#x3D;Enter project name:</span><br><span class="line">cd %option%</span><br><span class="line">set&#x2F;p keep&#x3D;Need &#39;Npm run dev&#39;?(y&#x2F;n)</span><br><span class="line">:: 区分输入指令</span><br><span class="line">set dev&#x3D;0</span><br><span class="line">if &quot;%keep%&quot;&#x3D;&#x3D;&quot;y&quot; (</span><br><span class="line">    set dev&#x3D;1</span><br><span class="line">) else if &quot;%keep%&quot;&#x3D;&#x3D;&quot;Y&quot; (</span><br><span class="line">    set dev&#x3D;2</span><br><span class="line">) else if &quot;%keep%&quot;&#x3D;&#x3D;&quot;&quot; (</span><br><span class="line">    set dev&#x3D;3</span><br><span class="line">) else if &quot;%keep%&quot;&#x3D;&#x3D;&quot;n&quot; (</span><br><span class="line">    set dev&#x3D;-1</span><br><span class="line">) else if &quot;%keep%&quot;&#x3D;&#x3D;&quot;N&quot; (</span><br><span class="line">    set dev &#x3D; -2</span><br><span class="line">)</span><br><span class="line">:: 运行程序</span><br><span class="line">if %dev% gtr 0 (</span><br><span class="line">    start cmd &#x2F;c %nodevars%&amp;&amp;npm run dev</span><br><span class="line">) else (</span><br><span class="line">    start cmd &#x2F;k %nodevars%</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="多项目-多任务"><a href="#多项目-多任务" class="headerlink" title="多项目,多任务"></a>多项目,多任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">echo 1</span><br><span class="line">@echo off</span><br><span class="line">@rem &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">:menu</span><br><span class="line">e:</span><br><span class="line">cls</span><br><span class="line"></span><br><span class="line">echo.</span><br><span class="line">:choseDir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  选择项目目录 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo.</span><br><span class="line">echo                       1:    \atest&#x2F;webpack1</span><br><span class="line">echo                       2:    \net-tj-EL-ZRZS-Front-master\EL-ZRZS-Front21</span><br><span class="line">echo                       3:    compass-project</span><br><span class="line">echo                       4:    yeoman-project </span><br><span class="line">echo.</span><br><span class="line">echo                       P:    ??Git??????</span><br><span class="line">echo                       Q:    ??</span><br><span class="line">echo.</span><br><span class="line">echo              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 选择项目目录 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo.</span><br><span class="line">set&#x2F;p option&#x3D;Enter project path:</span><br><span class="line">if &quot;%option%&quot;&#x3D;&#x3D;&quot;1&quot; (</span><br><span class="line">    cd &quot;atest&#x2F;webpack1&quot;</span><br><span class="line">)else if &quot;%option%&quot;&#x3D;&#x3D;&quot;2&quot; (</span><br><span class="line">    cd &quot;net-tj-EL-ZRZS-Front-master\EL-ZRZS-Front21&quot;</span><br><span class="line">)else if &quot;%option%&quot;&#x3D;&#x3D;&quot;&quot; (</span><br><span class="line">    cd &quot;net-tj-EL-ZRZS-Front-master\EL-ZRZS-Front21&quot;</span><br><span class="line">)else if &quot;%option%&quot;&#x3D;&#x3D;&quot;9&quot; (</span><br><span class="line">    goto gofirst</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:dosomething</span><br><span class="line">echo.</span><br><span class="line">echo              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  你想干什么 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo.</span><br><span class="line">echo1:   运行项目</span><br><span class="line">echo2:   打包</span><br><span class="line">echo3：  执行EsLint验证</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo9:   返回上一级</span><br><span class="line">echo.</span><br><span class="line">echo              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 你想干什么 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo.</span><br><span class="line">set&#x2F;p option1&#x3D;Enter dosomething(1&#x2F;2):</span><br><span class="line">    if &quot;%option1%&quot;&#x3D;&#x3D;&quot;&quot; (</span><br><span class="line">        start cmd &#x2F;c %nodevars%&amp;&amp;npm run dev</span><br><span class="line">    )else if &quot;%option1%&quot;&#x3D;&#x3D;&quot;1&quot; (</span><br><span class="line">        start cmd &#x2F;c %nodevars%&amp;&amp;npm run dev</span><br><span class="line">    ) else if &quot;%option1%&quot;&#x3D;&#x3D;&quot;2&quot; (</span><br><span class="line">        start cmd &#x2F;c %nodevars%&amp;&amp;npm run build:prod</span><br><span class="line">    ) else if &quot;%option1%&quot;&#x3D;&#x3D;&quot;9&quot; (</span><br><span class="line">    goto gofirst</span><br><span class="line">    ) else if &quot;%option1%&quot;&#x3D;&#x3D;&quot;3&quot; (</span><br><span class="line">    start cmd &#x2F;c %nodevars%&amp;&amp;npm run lint</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:gofirst</span><br><span class="line"></span><br><span class="line">cd..</span><br><span class="line">cd..</span><br><span class="line">cd..</span><br><span class="line"></span><br><span class="line">goto choseDir</span><br></pre></td></tr></table></figure><p>最后效果<br><img src= "/img/loading.gif" data-src="dosDemo.png" alt="Image text"><br>注意事项：中文乱码情况下，以记事本打开另存为ANSI格式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;单项目&quot;&gt;&lt;a href=&quot;#单项目&quot; class=&quot;headerlink&quot; title=&quot;单项目&quot;&gt;&lt;/a&gt;单项目&lt;/h3&gt;&lt;p&gt;例如需启动”d/vue”下的项目&lt;br&gt;新建run.text,写入以下内容，修改后缀名为.bat,双击运行项目&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
    
      <category term="DOS命令" scheme="http://weilonglong.top/tags/DOS%E5%91%BD%E4%BB%A4/"/>
    
      <category term="批处理脚本" scheme="http://weilonglong.top/tags/%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>前端常用正则库</title>
    <link href="http://weilonglong.top/2020/08/03/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E5%BA%93/"/>
    <id>http://weilonglong.top/2020/08/03/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E5%BA%93/</id>
    <published>2020-08-03T02:36:57.000Z</published>
    <updated>2020-08-09T14:43:36.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="是否合法IP地址"><a href="#是否合法IP地址" class="headerlink" title="是否合法IP地址"></a>是否合法IP地址</h3><p>export function validateIP(rule, value, callback) {<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    const reg = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的IP地址’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否手机号码或者固话"><a href="#是否手机号码或者固话" class="headerlink" title="是否手机号码或者固话"></a>是否手机号码或者固话</h3><p>export function validatePhoneTwo(rule, value, callback) {<br>  const reg = /^((0\d{2,3}-\d{7,8})|(1[34578]\d{9}))$/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的电话号码或者固话号码’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否固话"><a href="#是否固话" class="headerlink" title="是否固话"></a>是否固话</h3><p>export function validateTelphone(rule, value, callback) {<br>  const reg = /0\d{2}-\d{7,8}/<br>  if (value === ‘’ || value === undefined || value === null) {<br>    callback()<br>  } else {<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的固话（格式：区号+号码,如010-1234567）’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否手机号码"><a href="#是否手机号码" class="headerlink" title="是否手机号码"></a>是否手机号码</h3><p>export function validatePhone(rule, value, callback) {<br>  const reg = /^[1][3,4,5,7,8][0-9]{9}$/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的电话号码’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否身份证号码"><a href="#是否身份证号码" class="headerlink" title="是否身份证号码"></a>是否身份证号码</h3><p>export function validateIdNo(rule, value, callback) {<br>  const reg = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的身份证号码’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否邮箱"><a href="#是否邮箱" class="headerlink" title="是否邮箱"></a>是否邮箱</h3><p>export function validateEMail(rule, value, callback) {<br>  const reg = /^([a-zA-Z0-9]+[-_.]?)+@[a-zA-Z0-9]+.[a-z]+$/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if (!reg.test(value)) {<br>      callback(new Error(‘请输入正确的邮箱地址’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="合法uri"><a href="#合法uri" class="headerlink" title="合法uri"></a>合法uri</h3><p>export function validateURL(textval) {<br>  const urlregex = /^(https?|ftp)://([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&amp;%$-]+)<em>@)</em>((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+.)<em>[a-zA-Z0-9-]+.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]+)</em>(/($|[a-zA-Z0-9.,?’\+&amp;%$#=~_-]+))*$/<br>  return urlregex.test(textval)<br>}</p><h3 id="验证内容是否英文数字以及下划线"><a href="#验证内容是否英文数字以及下划线" class="headerlink" title="验证内容是否英文数字以及下划线"></a>验证内容是否英文数字以及下划线</h3><p>export function isPassword(rule, value, callback) {<br>  const reg = /^[_a-zA-Z0-9]+$/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if (!reg.test(value)) {<br>      callback(new Error(‘密码仅由英文字母，数字以及下划线组成’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="自动检验数值的范围"><a href="#自动检验数值的范围" class="headerlink" title="自动检验数值的范围"></a>自动检验数值的范围</h3><p>export function checkMax20000(rule, value, callback) {<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else if (!Number(value)) {<br>    callback(new Error(‘请输入[1,20000]之间的数字’))<br>  } else if (value &lt; 1 || value &gt; 20000) {<br>    callback(new Error(‘请输入[1,20000]之间的数字’))<br>  } else {<br>    callback()<br>  }<br>}</p><h3 id="验证数字输入框最大数值-32767"><a href="#验证数字输入框最大数值-32767" class="headerlink" title="验证数字输入框最大数值,32767"></a>验证数字输入框最大数值,32767</h3><p>export function checkMaxVal(rule, value, callback) {<br>  if (value &lt; 0 || value &gt; 32767) {<br>    callback(new Error(‘请输入[0,32767]之间的数字’))<br>  } else {<br>    callback()<br>  }<br>}</p><h3 id="验证是否1-99之间"><a href="#验证是否1-99之间" class="headerlink" title="验证是否1-99之间"></a>验证是否1-99之间</h3><p>export function isOneToNinetyNine(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入正整数’))<br>    } else {<br>      const re = /^[1-9][0-9]{0,1}$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入正整数，值为【1,99】’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 0)<br>}</p><h3 id="验证是否整数"><a href="#验证是否整数" class="headerlink" title="验证是否整数"></a>验证是否整数</h3><p>export function isInteger(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入正整数’))<br>    } else {<br>      const re = /^[0-9]<em>[1-9][0-9]</em>$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入正整数’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 0)<br>}</p><h3 id="验证是否整数-非必填"><a href="#验证是否整数-非必填" class="headerlink" title="验证是否整数,非必填"></a>验证是否整数,非必填</h3><p>export function isIntegerNotMust(rule, value, callback) {<br>  if (!value) {<br>    callback()<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入正整数’))<br>    } else {<br>      const re = /^[0-9]<em>[1-9][0-9]</em>$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入正整数’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 1000)<br>}</p><h3 id="验证是否是-0-1-的小数"><a href="#验证是否是-0-1-的小数" class="headerlink" title="验证是否是[0-1]的小数"></a>验证是否是[0-1]的小数</h3><p>export function isDecimal(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入[0,1]之间的数字’))<br>    } else {<br>      if (value &lt; 0 || value &gt; 1) {<br>        callback(new Error(‘请输入[0,1]之间的数字’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证是否是-1-10-的小数-即不可以等于0"><a href="#验证是否是-1-10-的小数-即不可以等于0" class="headerlink" title="验证是否是[1-10]的小数,即不可以等于0"></a>验证是否是[1-10]的小数,即不可以等于0</h3><p>export function isBtnOneToTen(rule, value, callback) {<br>  if (typeof value === ‘undefined’) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入正整数，值为[1,10]’))<br>    } else {<br>      if (!(value === ‘1’ || value === ‘2’ || value === ‘3’ || value === ‘4’ || value === ‘5’ || value === ‘6’ || value === ‘7’ || value === ‘8’ || value === ‘9’ || value === ‘10’)) {<br>        callback(new Error(‘请输入正整数，值为[1,10]’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证是否是-1-100-的小数-即不可以等于0"><a href="#验证是否是-1-100-的小数-即不可以等于0" class="headerlink" title="验证是否是[1-100]的小数,即不可以等于0"></a>验证是否是[1-100]的小数,即不可以等于0</h3><p>export function isBtnOneToHundred(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入整数，值为[1,100]’))<br>    } else {<br>      if (value &lt; 1 || value &gt; 100) {<br>        callback(new Error(‘请输入整数，值为[1,100]’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证是否是-0-100-的小数"><a href="#验证是否是-0-100-的小数" class="headerlink" title="验证是否是[0-100]的小数"></a>验证是否是[0-100]的小数</h3><p>export function isBtnZeroToHundred(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入[1,100]之间的数字’))<br>    } else {<br>      if (value &lt; 0 || value &gt; 100) {<br>        callback(new Error(‘请输入[1,100]之间的数字’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证端口是否在-0-65535-之间"><a href="#验证端口是否在-0-65535-之间" class="headerlink" title="验证端口是否在[0,65535]之间"></a>验证端口是否在[0,65535]之间</h3><p>export function isPort(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (value === ‘’ || typeof (value) === undefined) {<br>      callback(new Error(‘请输入端口值’))<br>    } else {<br>      const re = /^([0-9]|[1-9]\d|[1-9]\d{2}|[1-9]\d{3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入在[0-65535]之间的端口值’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证端口是否在-0-65535-之间，非必填-isMust表示是否必填"><a href="#验证端口是否在-0-65535-之间，非必填-isMust表示是否必填" class="headerlink" title="验证端口是否在[0,65535]之间，非必填,isMust表示是否必填"></a>验证端口是否在[0,65535]之间，非必填,isMust表示是否必填</h3><p>export function isCheckPort(rule, value, callback) {<br>  if (!value) {<br>    callback()<br>  }<br>  setTimeout(() =&gt; {<br>    if (value === ‘’ || typeof (value) === undefined) {<br>      // callback(new Error(‘请输入端口值’));<br>    } else {<br>      const re = /^([0-9]|[1-9]\d|[1-9]\d{2}|[1-9]\d{3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入在[0-65535]之间的端口值’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="小写字母"><a href="#小写字母" class="headerlink" title="小写字母"></a>小写字母</h3><p>export function validateLowerCase(str) {<br>  const reg = /^[a-z]+$/<br>  return reg.test(str)<br>}</p><h3 id="验证key"><a href="#验证key" class="headerlink" title="验证key"></a>验证key</h3><p>// export function validateKey(str) {<br>//     var reg = /^[a-z_-:]+$/;<br>//     return reg.test(str);<br>// }</p><h3 id="大写字母"><a href="#大写字母" class="headerlink" title="大写字母"></a>大写字母</h3><p>export function validateUpperCase(str) {<br>  const reg = /^[A-Z]+$/<br>  return reg.test(str)<br>}</p><h3 id="大小写字母"><a href="#大小写字母" class="headerlink" title="大小写字母"></a>大小写字母</h3><p>export function validatAlphabets(rule, str, callback) {<br>  const reg = /^[A-Za-z]+$/<br>  const regTest = reg.test(str)<br>  if (!regTest) {<br>    callback(new Error(‘大小写字母’))<br>  } else {<br>    callback()<br>  }<br>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;是否合法IP地址&quot;&gt;&lt;a href=&quot;#是否合法IP地址&quot; class=&quot;headerlink&quot; title=&quot;是否合法IP地址&quot;&gt;&lt;/a&gt;是否合法IP地址&lt;/h3&gt;&lt;p&gt;export function validateIP(rule, value, callba
      
    
    </summary>
    
    
    
      <category term="正则表达式" scheme="http://weilonglong.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vuex的使用总结</title>
    <link href="http://weilonglong.top/2020/08/01/vuex%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://weilonglong.top/2020/08/01/vuex%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-08-01T02:21:39.000Z</published>
    <updated>2020-08-09T14:43:36.558Z</updated>
    
    <content type="html"><![CDATA[<p>vuex是一个专门未vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>使用  npm install vuex –save<br>新建store文件夹/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">import user from &#39;.&#x2F;modules&#x2F;user.js&#39;</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    modules:&#123;</span><br><span class="line">        user</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default store</span><br></pre></td></tr></table></figure><h3 id="在将store挂载到Vue的根组件上"><a href="#在将store挂载到Vue的根组件上" class="headerlink" title="在将store挂载到Vue的根组件上"></a>在将store挂载到Vue的根组件上</h3><p>main.js中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &#39;#app&#39;,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5个核心概念"><a href="#5个核心概念" class="headerlink" title="5个核心概念"></a>5个核心概念</h3><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><pre><code>其仓库</code></pre><h4 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h4><pre><code>用于同步更新store中的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">    state.count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><pre><code>用于异步更新store中的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">    &#x2F;&#x2F; context.commit(&#39;increment&#39;)</span><br><span class="line">    setTimeout(function () &#123; context.commit(&#39;increment&#39;) &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><pre><code>相当于计算属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> getters: &#123;</span><br><span class="line">    doneTodos: state &#x3D;&gt; &#123;</span><br><span class="line">        return state.countNum + state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    user: state &#x3D;&gt; state.user.user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><pre><code>将store进行分块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import user from &#39;.&#x2F;modules&#x2F;user.js&#39;</span><br><span class="line">modules: &#123;</span><br><span class="line">    user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其中modules下的user.js这么写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">    state: () &#x3D;&gt; (&#123; user: 3 &#125;),</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        changeUser (state) &#123;</span><br><span class="line">            state.user +&#x3D; 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        asyncChangeUser (context) &#123;</span><br><span class="line">            context.commit(&#39;changeUser&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        getUserAge: state &#x3D;&gt; state.user + &#39;岁&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default user</span><br></pre></td></tr></table></figure>访问时使用this.$store.state.user.user可以得到3使用this.$store.dispatch(&apos;asyncChnageUser&apos;)可以异步修改user模块中的user使用this.$store.commit(&apos;changeUser&apos;)可以同步修改user模块中的user使用this.getters.getUserAge 可以动态计算岁数</code></pre><h4 id="一次性引入所有modules"><a href="#一次性引入所有modules" class="headerlink" title="一次性引入所有modules"></a>一次性引入所有modules</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import getters from &#39;.&#x2F;getters.js&#39;</span><br><span class="line">&#x2F;&#x2F; import user from &#39;.&#x2F;modules&#x2F;user.js&#39;</span><br><span class="line">const modulesFiles &#x3D; require.context(&#39;.&#x2F;modules&#39;, true, &#x2F;\.js$&#x2F;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; you do not need &#96;import app from &#39;.&#x2F;modules&#x2F;app&#39;&#96;</span><br><span class="line">&#x2F;&#x2F; it will auto require all vuex module from modules file</span><br><span class="line">const modules &#x3D; modulesFiles.keys().reduce((modules, modulePath) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; set &#39;.&#x2F;app.js&#39; &#x3D;&gt; &#39;app&#39;</span><br><span class="line">const moduleName &#x3D; modulePath.replace(&#x2F;^\.\&#x2F;(.*)\.\w+$&#x2F;, &#39;$1&#39;)</span><br><span class="line">const value &#x3D; modulesFiles(modulePath)</span><br><span class="line">modules[moduleName] &#x3D; value.default</span><br><span class="line">return modules</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line">const state&#x3D; new Vue.store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters,</span><br><span class="line">    modules</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre><h4 id="module中开启命名空间"><a href="#module中开启命名空间" class="headerlink" title="module中开启命名空间"></a>module中开启命名空间</h4><p>在module中开启命名空间,加一个属性namespaced:true即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">  namespaced: true, &#x2F;&#x2F;开启命名空间</span><br><span class="line">  state: () &#x3D;&gt; (&#123; user: 3 &#125;),</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeUser (state) &#123;</span><br><span class="line">      state.user +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    asyncChnageUser (context) &#123;</span><br><span class="line">      context.commit(&#39;changeUser&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getUserAge: state &#x3D;&gt; state.user + &#39;岁&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default user</span><br></pre></td></tr></table></figure><h5 id="进行action修改时"><a href="#进行action修改时" class="headerlink" title="进行action修改时"></a>进行action修改时</h5><p><code>this.$store.dispatch(&#39;user/asyncChnageUser&#39;)</code></p><h5 id="进行mutations修改时"><a href="#进行mutations修改时" class="headerlink" title="进行mutations修改时"></a>进行mutations修改时</h5><p><code>this.$store.dispath(&#39;user/changeUser&#39;)</code></p><h5 id="进行获取getters时"><a href="#进行获取getters时" class="headerlink" title="进行获取getters时"></a>进行获取getters时</h5><p><code>this.$store.getters[&#39;user/getUserAge&#39;]</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vuex是一个专门未vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;h3 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://weilonglong.top/tags/Vue/"/>
    
      <category term="Vuex" scheme="http://weilonglong.top/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>数组降维方式</title>
    <link href="http://weilonglong.top/2020/07/25/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
    <id>http://weilonglong.top/2020/07/25/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4%E6%96%B9%E5%BC%8F/</id>
    <published>2020-07-25T14:31:39.000Z</published>
    <updated>2020-07-27T15:43:49.572Z</updated>
    
    <content type="html"><![CDATA[<ul><li>数组字符串化<a id="more"></a>所有类型会转成字符串，且元素为对象类型会被转换成”[object Object]”,对于同一种类型数字或字符串还是可以的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [[1,2,3],[4,5,6],&#123;a:1&#125;]</span><br><span class="line">arr+&#x3D;&#39;&#39;</span><br><span class="line">arr &#x3D; arr.split(&#39;,&#39;)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;[object Object]&quot;]</span><br></pre></td></tr></table></figure></li><li>递归<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reduceDimension(arr)&#123;</span><br><span class="line">    let ret &#x3D; []</span><br><span class="line">    let toArr &#x3D; fuinction(arr)&#123;</span><br><span class="line">       arr.forEach(function(item)&#123;</span><br><span class="line">           item instanceof Array ? toArr(item) : ret.push(item)</span><br><span class="line">       &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">    toArr(arr)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Array.prototype.flat()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1,2,[3,4]]</span><br><span class="line">arr.flat() &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line"></span><br><span class="line">var arr2 &#x3D; [1,2,[3,4,[5,6]]]</span><br><span class="line">arr2.flat() &#x2F;&#x2F;[1,2,3,4,[5,6]]</span><br><span class="line"></span><br><span class="line">var arr3 &#x3D; [1,2,[3,4,[5,6]]]</span><br><span class="line">arr3.flat(2) &#x2F;&#x2F;[1,2,3,4,5,6]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用Infinity作为深度，展开任意层度的嵌套数组</span><br><span class="line">arr3.flat(Infinity) &#x2F;&#x2F;[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure></li><li>使用stack无限反嵌套多层嵌套数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1,2,3,[1,2,3,4,[2,3,4]]]</span><br><span class="line">function flatten(input)&#123;</span><br><span class="line">    const stack &#x3D; [...input]</span><br><span class="line">    const res &#x3D; []</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">        &#x2F;&#x2F; 使用pop从stack中取出并移除值</span><br><span class="line">        const next &#x3D; stack.pop()</span><br><span class="line">        if(Array.isArray(next))&#123;</span><br><span class="line">            stack.push(...next)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res.push(next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res.reverse()</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr1)</span><br></pre></td></tr></table></figure></li><li>使用reduce、concat和递归无限反嵌套多层嵌套的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1,2,3,[2,3,4,[3,4,5,[4,5,6]]]]</span><br><span class="line">function flattenDeep(arr1)&#123;</span><br><span class="line">    return arr1.reduce((acc,val)&#x3D;&gt;Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);</span><br><span class="line">&#125;</span><br><span class="line">flattenDeep(arr1) &#x2F;&#x2F;  [1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;数组字符串化
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://weilonglong.top/tags/JavaScript/"/>
    
      <category term="Array" scheme="http://weilonglong.top/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>ES11</title>
    <link href="http://weilonglong.top/2020/07/25/ES11/"/>
    <id>http://weilonglong.top/2020/07/25/ES11/</id>
    <published>2020-07-25T14:31:06.000Z</published>
    <updated>2020-08-09T14:43:36.557Z</updated>
    
    <content type="html"><![CDATA[<ul><li>私有属性</li></ul><a id="more"></a><p>在ES11 中提供了私有变量，通过在变量或函数钱增加一个哈希符号#,即可设为私有属性，只能在类的内部使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    #age &#x3D; 0</span><br><span class="line">    constructor(age)&#123;</span><br><span class="line">        this.#age &#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">    getAge()&#123;</span><br><span class="line">        return this.#age</span><br><span class="line">    &#125;</span><br><span class="line">    setAge(age)&#123;</span><br><span class="line">        this.#age +&#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let zhangsan &#x3D; new Age(12)</span><br><span class="line">zhangsan.getAge() &#x2F;&#x2F; 12</span><br><span class="line">zhangsan.setAge(2) </span><br><span class="line">zhangsan.getAge() &#x2F;&#x2F; 14</span><br><span class="line">zhangsan.#age &#x3D; 18 &#x2F;&#x2F; Private field &#39;#age&#39; must be declared in an enclosing class</span><br><span class="line">console.log(zhangsan.#age) &#x2F;&#x2F; Private field &#39;#age&#39; must be declared in an enclosing class</span><br></pre></td></tr></table></figure><ul><li>空值合并运算符<br>取对象属性，如果这个属性没有值，会给默认值.<br>当左侧操作数为null或者undefined时，返回右侧的值，否则返回左侧的值。<br>?? 和 || 的区别:<br>|| 会首先对左侧的值进行boolean类型转换。当左侧值为” “或者是0时，会返回右侧的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let zhangsan &#x3D; &#123;</span><br><span class="line">    age: 12,</span><br><span class="line">    sex: 1,</span><br><span class="line">    hasHouse: 0</span><br><span class="line">&#125;</span><br><span class="line">console.log(zhangsan.age) &#x2F;&#x2F; 12</span><br><span class="line">console.log(zhangsan.sex) &#x2F;&#x2F; 1</span><br><span class="line">console.log(zhangsan.wife || &#39;未婚&#39;) &#x2F;&#x2F; 未婚</span><br><span class="line">console.log(zhangsan.hobby ?? &#39;打篮球&#39;) &#x2F;&#x2F; 打蓝球</span><br><span class="line">console.log(zhangsan.hasHouse || &#39;2&#39;) &#x2F;&#x2F; 2</span><br><span class="line">console.log(zhangsan.hasHouse ?? &#39;1&#39;) &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure></li><li>可选链操作符<br>减少访问深层次对象时判断属性存不存在的问题。<br>可选链中的?.表示问号左侧表达式有值，就回查询问号后面的字段。根据下面的结果可以看出，用可选链可以大量简化类似繁琐的前置校验操作，而且更安全。<br>?.不能用来赋值<br>通常可选链操作符与空值合并运算符一起使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; &#123;c:&#123;d:&#39;d&#39;&#125;&#125;</span><br><span class="line">console.log(a.b.c) &#x2F;&#x2F; 这里是Err，无法从undefined中得到c</span><br><span class="line">console.log(a?.c?.d) &#x2F;&#x2F; d</span><br><span class="line">console.log(a?.b?.c) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(a?.b?.c ?? &#39;e&#39;) &#x2F;&#x2F; e</span><br></pre></td></tr></table></figure></li><li>动态引入<br>在项目中，某些功能可能很少使用，而导入所有依赖项可能只是浪费资源。现在可以使用async/await在需要时动态导入依赖项，可以在初始化的时候不全部加载逻辑资源，只进行按需加载这样可以让首屏的渲染速度更快，<br>demo.js导出模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const num &#x3D; (sum1,sum2)&#x3D;&gt;sum1+sum2</span><br></pre></td></tr></table></figure>html中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">    const testAsync &#x3D; async(num1,num2)&#x3D;&gt;&#123;</span><br><span class="line">        let models &#x3D; await import(&#39;.&#x2F;demo.js&#39;)</span><br><span class="line">        console.log(models.num(num1,num2))</span><br><span class="line">    &#125;</span><br><span class="line">    testAsync(1,2)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>Access to script at ‘file:///C:/Users/Administrator/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/demo.js’ from origin ‘null’ has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.  需要在http环境进行</li></ul><ol><li>方法1：在VSCode中安装living server插件，将文件夹拖到工作区，点击living</li><li>npm i http-server -g 安装依赖，在目录执行http-server</li></ol><ul><li>globalThis<br>js在不同环境下的环境，获取全局对象是不一样的。NodeJs中通过global,Web中通过window,self等，有些甚至可以通过this。</li></ul><ul><li>全局变量window：是一个经典的获取全局对象的方法。但是它在Node.js和Web Workers中并不能使用。</li><li>全局变量self：通常只在Web Workers和浏览器中生效，但是它不支持Node.js</li><li>全局global：只在Nodel.js中生效<br>如果写一段js，可能在Node环境中运行，也可能在浏览器端，也可能在Web Workers环境中运行。这时候全局变量，必须使用一个方法去判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var getGlober &#x3D; function()&#123;</span><br><span class="line">    if(typeof self !&#x3D;&#x3D; &#39;undefined&#39;)&#123;return self&#125;</span><br><span class="line">    if(typeof window !&#x3D;&#x3D; &#39;undefined&#39;)&#123;return window&#125;</span><br><span class="line">    if(typeof globel !&#x3D;&#x3D; &#39;undefined&#39;)&#123;return global&#125;</span><br><span class="line">    thrownewError(&#39;unable to locate global object&#39;)</span><br><span class="line">&#125;</span><br><span class="line">var globals &#x3D; getGlober()</span><br></pre></td></tr></table></figure>ES11 中提供了globalThis，提供了标准化方式访问全局对象，有了globalThis后，可以在任意上下文，任意时刻获取到全局对象。<br>globalThis提供了一个标准的方式来获取不同环境下的全局this对象，所以不用担心运行环境。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; worker.js</span><br><span class="line">console.log(globelThis &#x3D;&#x3D;&#x3D; this) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; node.js</span><br><span class="line">console.log(globelThis &#x3D;&#x3D;&#x3D; this) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 浏览器</span><br><span class="line">console.log(globelThis &#x3D;&#x3D;&#x3D; window) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Promise.all缺陷<br>Promise.all具有并发执行异步任务的功能。最大的问题是如果某个任务出现异常(reject)，所有任务都会挂掉，Promise直接进入reject状态。<br>如果一个页面有3个区域，分别对应3个独立的接口数据，使用Promise.all来并发三个接口，如果其中一个接口服务异常，状态是reject，这会导致页面中3个区域的数据都无法渲染，因为reject都会进入catch回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let a&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  resolve(&#123; code: 200,msg:&quot;请求成功&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let b&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  resolve(&#123; code: 200,msg:&quot;请求成功&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let c&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  reject(&#123; code: 500,msg:&quot;服务器出现异常&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;使用Promise.all 进行并发执行异步任务</span><br><span class="line">Promise.all([a,b,c])</span><br><span class="line">.then((res) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 只有 上面所有的请求都是 resolve (成功) 的时候才会进入此回调中</span><br><span class="line">    console.log(res,&quot;res&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">.catch((error) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 上面的请求中，只要有一个是reject (失败) 就会进入此回调</span><br><span class="line">    console.log(error,&quot;error&quot;)</span><br><span class="line">    &#x2F;&#x2F; error: &#123;code: 500, msg: &quot;服务异常&quot;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Promise.allSettled<br>当我们处理多个Promise时，尤其是他们互相依赖时，记录每个事件在调试中发生的错误可能很有用。使用Promise.allSettled，他会创建一个新的Promise，在所有Promise完成后返回一个promise结果的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let a&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  resolve(&#123; code: 200,msg:&quot;请求成功&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let b&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  resolve(&#123; code: 200,msg:&quot;请求成功&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let c&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  reject(&#123; code: 500,msg:&quot;服务器出现异常&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;使用进行并发请求</span><br><span class="line">Promise.allSettled([a,b,c]).then((data&#x3D;&gt;&#123;</span><br><span class="line">  console.log(data,&quot;data&quot;)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回的数据中 ，status: &quot;fulfilled&quot; 表示请求成功，status: &quot;rejected&quot; 表示请求失败</span><br></pre></td></tr></table></figure></li><li><p>Promise.allSettled的优势<br>Promise.allSettled跟Promise.all类似，都是并发进行，他们的区别在于Promise.all进行并发请求的时候，只要有一个请求出现问题（异常），所有的请求正常也不能拿到数据，但是在我们的业务的开发中，我们需要保障我们业务的最大的可访问性，就是在我们执行并发任务中，不管我这个并发任务中的任何一个任务是正常还是异常，我们都需要拿到返回的对应的状态，在ES11中Promise.allSettled就为我们解决了这个问题，他和Promise.all类似，参数接收一个Promise的数组，返回一个新的Promise，也就是说当Promise全部处理完成后，我们可以拿到每个Promise的状态，而不管是否处理成功。我们可以在then里边通过filter来过滤想要的业务逻辑结果，这样就解决了Promise.all的缺陷。</p></li><li><p>BigInt 任意精度整数</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;私有属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://weilonglong.top/tags/JavaScript/"/>
    
      <category term="ES11" scheme="http://weilonglong.top/tags/ES11/"/>
    
  </entry>
  
  <entry>
    <title>javaScript中的LHS和RHS查询</title>
    <link href="http://weilonglong.top/2020/07/25/javaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%E6%9F%A5%E8%AF%A2/"/>
    <id>http://weilonglong.top/2020/07/25/javaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-07-25T14:30:32.000Z</published>
    <updated>2020-07-25T15:21:22.360Z</updated>
    
    <content type="html"><![CDATA[<p>LHS查询：赋值操作左侧的查询，LHS查询视图找到变量的容器本身，从而对其赋值<br>RHS查询：赋值操作右侧的查询，可以理解为”取到某某的值”</p><a id="more"></a><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">    var b &#x3D; a;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">var c &#x3D; foo(2)</span><br></pre></td></tr></table></figure><p>以上代码有3个LHS与4个RHS</p><ol><li>var c中的c需要被复制，在赋值操作符的左侧，对c进行了LHS引用</li><li>变量c需要被赋值，他的值是foo(2)，那么foo(2)的值多少呢，需要查找foo(2)的值，在赋值操作的右侧，所以对foo(2)进行RHS引用</li><li>隐含赋值操作，将2传递给function foo(a) {}函数的参数a，a在赋值操作的左侧，对a进行了LHS引用</li><li>var b = a，b需要被赋值，处在赋值操作的左侧，所以b进行了LHS，b的值将从a来，那么右侧的a的值从何而来呢，这就需要赋值操作右侧的a进行RHS。</li><li>return a+b 需要找到a与b的值来源，a与b都在赋值操作的右侧，才能得到a+b的制作，所以对a与b都是RHS引用</li></ol><p>为什么要区分LHS与RHS？<br>因为在变量还没有声明（在任何作用域中都无法找到该变量）情况下，这两种查询行为是不一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a)&#123;</span><br><span class="line">    console.log(a+b)</span><br><span class="line">    b&#x3D;a;</span><br><span class="line">&#125;</span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure><p>以上代码对b进行RHS的时候无法找到该变量的值，则会抛出ReferenxeError异常，如果是LHS找不到变量，非严格模式下，会在全局作用域中，创建一个具有该名称的变量，严格模式下，会跑出与RHS类似的异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function init(a)&#123;</span><br><span class="line">    b &#x3D; a + 3</span><br><span class="line">&#125;</span><br><span class="line">init(2)</span><br><span class="line">alert(b)</span><br></pre></td></tr></table></figure><p>以上代码，对b进行LHS没有找到变量，在全局作用域中创建了一个同名的变量b，在函数init外部可以访问到b变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function init()&#123;</span><br><span class="line">    var b &#x3D; a + 3</span><br><span class="line">&#125;</span><br><span class="line">init(2)</span><br><span class="line">alert(b)</span><br></pre></td></tr></table></figure><p>在function中定义了一个局部变量b，全局作用域中定义，控制台报错。<br>Uncaught ReferenceError：b is not defined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function init(a)&#123;</span><br><span class="line">    var b&#x3D;a+3</span><br><span class="line">&#125;</span><br><span class="line">init(2)</span><br><span class="line">alert(window.b)</span><br></pre></td></tr></table></figure><p>将代码改成如下所示，控制台没有报错，因为window.b作为weindow的一个属性访问，所以会返回undefined，而b作为 一个变量没有定义的时候是会报错的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LHS查询：赋值操作左侧的查询，LHS查询视图找到变量的容器本身，从而对其赋值&lt;br&gt;RHS查询：赋值操作右侧的查询，可以理解为”取到某某的值”&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>节抖和防流</title>
    <link href="http://weilonglong.top/2020/07/25/%E8%8A%82%E6%8A%96%E5%92%8C%E9%98%B2%E6%B5%81/"/>
    <id>http://weilonglong.top/2020/07/25/%E8%8A%82%E6%8A%96%E5%92%8C%E9%98%B2%E6%B5%81/</id>
    <published>2020-07-25T14:29:43.000Z</published>
    <updated>2020-07-27T15:42:16.353Z</updated>
    
    <content type="html"><![CDATA[<p>节抖和防流的源码实现</p><a id="more"></a><table><thead><tr><th></th><th>防抖</th><th>节流</th></tr></thead><tbody><tr><td>概念</td><td>一段时间内频繁触发同一件事件，只会最后之星一次事件函数</td><td>在规定的时间内，无论触发多频繁，会且只会执行一次事件函数</td></tr><tr><td>实现原理（延时处理）</td><td>设置一个计时器，约定在XX毫秒后再触发事件处理，每次触发事件都会重置计时器，直到x毫秒内无2次操作</td><td>设置一个定时器，约定XX毫秒后执行事件，如果时间到了，就执行函数，并重置定时器</td></tr><tr><td>应用场景</td><td>搜索框/滚动条的监听事件处理等。如果不做防抖，没输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费</td><td>窗口调整，页面滚动，请购疯狂点击等。防止用户去疯狂点击甚至是使用恶意脚本去实现疯狂点击按钮</td></tr><tr><td>区别</td><td>都可以极大的优化网络请求性能，提高用户体验。防抖是延迟执行，而节流是间隔执行。防抖每次触发事件都要重置计时器，而节流在计时器到时间后再清空计时器</td><td></td></tr><tr><td>缺点</td><td>每次清除定时器后重新计时，则延时时间变得更长</td><td>短时间内无法联系调用事件函数，只有等上一次触发规定延时过后才能调用</td></tr></tbody></table><p>防抖函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay) &#123; &#x2F;&#x2F; fn 回调函数 delay 延迟时间</span><br><span class="line">    let timer &#x3D; null</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; areuments</span><br><span class="line">        if(timer) &#123;</span><br><span class="line">            clearTimrout(time)</span><br><span class="line">        &#125;</span><br><span class="line">        timer &#x3D; setTimeout( () &#x3D;&gt; &#123;</span><br><span class="line">            fn.apply(context,args)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节流函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function thrttlr(fn, wait)&#123;</span><br><span class="line">    let timer &#x3D; null</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; arguments</span><br><span class="line">        if(!timer) &#123;</span><br><span class="line">            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                timer &#x3D; null</span><br><span class="line">                fn.apply(context, args)</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用两个时间戳lasttime旧时间戳和nowtime新时间戳，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, wait)&#123;</span><br><span class="line">    var lasttime &#x3D; 0;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let nowtime &#x3D; Date.now()</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; arguments</span><br><span class="line">        if(nowtime - lasttime &gt; wait)&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">            lasttime &#x3D; nowtime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;节抖和防流的源码实现&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://weilonglong.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6Promise</title>
    <link href="http://weilonglong.top/2020/07/25/ES6Promise/"/>
    <id>http://weilonglong.top/2020/07/25/ES6Promise/</id>
    <published>2020-07-25T14:28:45.000Z</published>
    <updated>2020-07-27T16:16:04.825Z</updated>
    
    <content type="html"><![CDATA[ <!-- [ES6 Promise](https://www.cnblogs.com/lvdabao/p/es6-promise-1.html#!comments) --><p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样眼熟的方法。用Promise new出来的对象也是同样有then、catch方法的。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行成功&#39;)</span><br><span class="line">        resolve(&#39;随便什么数据&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>Promise的构造函数接收一个参数，是函数，并且传入两个参数resolve，reject，分别表示一步操作执行成功后的回调函数和异步操作失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来说，reslove是将Promise的状态设置为fullfiled，reject是将Promise的状态设置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p><p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并调用resolve()方法、</p><p>运行程序，会在2秒后输出“执行完成”。注意！我只是new了一个对象。并没有调用它，我们传进去的韩束就已经执行，这需要注意的细节。所以我们用Promise的时候一般时包在一个函数中，在需要的时候去运行这个函数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function runAsync()&#123;</span><br><span class="line">    var p&#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&quot;执行完成&quot;)</span><br><span class="line">            resolve(&quot;随便什么数据&quot;)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line">    return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync()</span><br></pre></td></tr></table></figure><p>那么问题来了，我们为什么要包装一个函数？这个resolve(“随便什么数据”)；这是干什么用的</p><p>在我们包装好的函数最后，会return出Promise，也就是说，执行这个函数我们得到了一个Promise对象，还记得Promise对象上有then、catch方法吧？这是强大之处，看下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runAsync().then(function()&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">    &#x2F;&#x2F; 可用于进行处理其他操作</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的参数。运行这段代码，会在2s后输出“执行完成”，紧接着输出“随便什么数据”</p><p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行后，用链式调用的方法执行回调函数。</p><p>那我将回调函数封装一下不是一样吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function runAsync(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行完成&#39;)</span><br><span class="line">        callback(&#39;随便什么数据&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;</span><br><span class="line">runAsync(function(data)&#123;</span><br><span class="line">    conole.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完也需要有相应的回调函数，该怎么办呢？总不能在定义一个callback2，然后给callback传进去吧。而Promise的优势在于可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><p>链式操作的用法</p><p>所以，从表面上看，Promise只能够简化蹭蹭回调的写法，而实质上，Promise的精髓是“状态”，用维护状态。传递状态的方式来使得回调函数能够即时调用，它比传递callback函数要简单、灵活的多。所以用Promise的正确场景是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">runAsync1()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">    return runAsync2()</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">    return runAsync3()</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样能够按顺序，每隔2秒输出每隔异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function runAsync1()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务1执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据1&#39;);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">function runAsync2()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务2执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据2&#39;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">function runAsync3()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务3执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据3&#39;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在then方法中，你可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们吧上面的代码修改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function runAsync1()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务1执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据1&#39;);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">function runAsync2()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务2执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据2&#39;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">function runAsync3()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务3执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据3&#39;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reject的用法<br>到这里，对‘Promise是什么玩意’有了基本的了解。那么我们看看还有什么其他功能。我们光用了了resolve，还没有用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中能补助到，然后执行“失败”情况的回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getNumber()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var num &#x3D; Math.ceil(Math.random()*10); &#x2F;&#x2F;生成1-10的随机数</span><br><span class="line">            if(num&lt;&#x3D;5)&#123;</span><br><span class="line">                resolve(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                reject(&#39;数字太大了&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">getNumber()</span><br><span class="line">.then(</span><br><span class="line">    function(data)&#123;</span><br><span class="line">        console.log(&#39;resolved&#39;);</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(reason, data)&#123;</span><br><span class="line">        console.log(&#39;rejected&#39;);</span><br><span class="line">        console.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是”成功”了，调用resolve修改Promise的状态，否则我们认为是失败了，调用reject并传递一个参数，作为失败的原因。</p><p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，会得到两种结果。</p><p>catch的用法</p><p>我们知道Promise对象除了then方法，haiyoucatch方法，他是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&#39;resolved&#39;);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&#39;rejected&#39;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样和写then的第二个参数里面一样，不过他还有另外一个作用，在执行resolve的回调（也就是上面then的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&#39;resolved&#39;);</span><br><span class="line">    console.log(data);</span><br><span class="line">    console.log(somedata); &#x2F;&#x2F;此处的somedata未定义</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&#39;rejected&#39;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(sonedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码执行到这里直接在控制台报错了，不往下运行了。但是在控制台会得到一些提示</p><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即使是有错误的代码也不会报错，这与我们的try/catch语句有相同功能。</p><p>all的用法<br>Promise的all方法提供了并行执行异步操作的能力，并且在 所有异步操作执行完成后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.all([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用Promise.all来执行，all接收一个数组参数，里面的值最终都返回Promise对象。这样，三个异步操作的并行执行的，等到它们执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。</p><p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？在一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载用到的各种资源，如图片，falsh以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p><p>race的用法<br>all方法的效果实际上是[谁跑得慢，以谁为准执行回调]，那么相对的就有另外一个方法[谁跑得快，就以谁为准执行回调]，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们吧上面runAsync1的延迟改为1秒来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.race([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三个异步操作同样是并行执行的。结果应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了</p><p>在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧在执行。于是再过1秒，输出他们执行结束的标志。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;请求某个图片资源</span><br><span class="line">    function requestImg()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        var img &#x3D; new Image();</span><br><span class="line">        img.onload &#x3D; function()&#123;</span><br><span class="line">            resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        img.src &#x3D; &#39;xxxxxx&#39;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;延时函数，用于给请求计时</span><br><span class="line">function timeout()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            reject(&#39;图片请求超时&#39;);</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise</span><br><span class="line">.race([requestImg(), timeout()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>requestImg函数会异步请求一张鱼片，将地址写为“XXXXX”所以肯定是无法请求到的，timeout函数是一个延迟5秒的异步操作，我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么便进入then方法，执行正常流程。如果5秒图片还未成功返回，那么timeout就跑赢了，则进入catch，报错“图片请求超时”的信息</p><p>总结：<br>ES6 Promise的内容就这些吗？是的，能用到的基本就这些。<br>我怎么还见过done、finally、success、file等，这些是啥？这些并不在Promise标准中，而是我们自己实现的语法糖。</p><p>本文中所有异步操作均已setTImeout为例子，之所以不使用ajax是为了避免引起混淆，因为谈起ajax，很多人的第一反应就是jquery的ajax，而jquery又有自己的Promise实现。</p>]]></content>
    
    <summary type="html">
    
      
      
         &lt;!-- [ES6 Promise](https://www.cnblogs.com/lvdabao/p/es6-promise-1.html#!comments) --&gt;

&lt;p&gt;Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原
      
    
    </summary>
    
    
    
      <category term="Promise" scheme="http://weilonglong.top/tags/Promise/"/>
    
      <category term="ES6" scheme="http://weilonglong.top/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>深入理解js创建对象</title>
    <link href="http://weilonglong.top/2020/07/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>http://weilonglong.top/2020/07/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-07-25T14:27:21.000Z</published>
    <updated>2020-07-27T15:42:32.602Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Object构造函数</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Object()</span><br><span class="line">person.name &#x3D; &#39;张三&#39;</span><br></pre></td></tr></table></figure><p>缺点：使用同一个接口创建很多对象，会产生大量的重复代码</p><ol start="2"><li>对象字面量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123; name:&#39;zhangsan&#39; &#125;</span><br></pre></td></tr></table></figure><p>缺点：同Object构造函数。使用用一个接口创建很多对象，会产生大量的重复代码</p><ol start="3"><li>Object.create方式</li></ol><p>Object.create()方法会使用指定的原型对象及其属性去创建一个新的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; &#123;</span><br><span class="line">    name :&#39;zhangsan&#39;</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; Object.create(Person)</span><br><span class="line">var person2 &#x3D; Object.create(Person)</span><br><span class="line">person1.sayName() &#x2F;&#x2F; &#39;zhangsan&#39;</span><br><span class="line">person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>优点：单例继承，语法简单。<br>缺点：封装性不好，多实例需要重复初始化过程。</p><ol start="4"><li>工厂模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name)&#123;</span><br><span class="line">    var o &#x3D; new Object()</span><br><span class="line">    o.name &#x3D; name</span><br><span class="line">    o.sayName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">    return o</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; createPerson(&#39;张三&#39;)</span><br><span class="line">var person2 &#x3D; createPerson(&#39;李四&#39;)</span><br></pre></td></tr></table></figure><p>优点：实现函数封装，无数次调用，都返回一个对象。<br>缺点：无法识别对象，因为所有实例的constructor都指向Object。</p><ol start="5"><li>构造函数模式</li></ol><p>构造函数模式：通过new关键字方式调用。<br>在构造函数内部，也就是被调用的函数内 this指向新创建的对象Object。这个新创建的对象的prototype被指向到构造函数的prototype。<br>如果被调用的函数没有显示的return表达式，则隐式的会返回this对象，也就是新创建的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.sayName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person(&#39;张三&#39;)</span><br><span class="line">var person2 &#x3D; new Person(&#39;李四&#39;)</span><br><span class="line">person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>优点：通过constructor或者instanceof可以识别对象实例的类别。<br>缺点：浪费内存。每个方法都要在每个实例上重新创建一遍。</p><ul><li>原型模式</li></ul><p>原型（prototype）：每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。原型对象（Person.prototype）是构造函数（Person）的一个实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.name &#x3D; &#39;张三&#39;</span><br><span class="line">Person.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person()</span><br><span class="line">person1.sayName() &#x2F;&#x2F; 张三</span><br><span class="line"></span><br><span class="line">var Person2 &#x3D; new Person()</span><br><span class="line">person2.sayName() &#x2F;&#x2F; 张三</span><br><span class="line"></span><br><span class="line">person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>通过prototype添加的属性和放大所有实例共享。</li><li>可以动态的添加原型对象的属性和方法，并直接反映到实例上<br>缺点：</li><li>实例无法重写原型中的值</li><li>访问实例的某个属性时，会先搜索对象实例本身，如果对象实例中具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，如果在原型对象中找到该属性，则返回该属性的值。</li></ul><ul><li>构造函数和原型的组合模式</li></ul><p>构造函数模式用于定义实例模式，而原型模式用于定于方法和共享的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.friends &#x3D; [&#39;张三&#39;, &#39;李四&#39;]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">    constructor: Person, &#x2F;&#x2F; 手动将constructor指向Person，否则constuctor将指向Object</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; new Person(&quot;one&quot;)</span><br><span class="line">var person2 &#x3D; new Person(&quot;two&quot;)</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;王五&quot;)</span><br><span class="line"></span><br><span class="line">person1.friends &#x2F;&#x2F; [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span><br><span class="line">person2.friends &#x2F;&#x2F; [&quot;张三&quot;, &quot;李四&quot;]</span><br><span class="line">person1.friends &#x3D;&#x3D;&#x3D; person2.friends &#x2F;&#x2F; false</span><br><span class="line">person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>优点：是使用最广泛、认同度最高的一种创建自定义类型的方法。</p><ul><li>每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法引用，最大限度地节省了内存；</li><li>支持向构造函数传递参数。</li></ul><p>缺点：缺乏更好的封装性</p><ul><li>动态原型模式</li></ul><p>动态原型密匙将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    if (typeof this.sayName !&#x3D;&#x3D; &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName &#x3D; function() &#123;</span><br><span class="line">            console.log(this.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person(&quot;a&quot;)</span><br><span class="line">person.sayName()</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>仅在需要的时候初始化原型，节省内存；</li><li>对原型所做的修改，都能立即在所有实例中得到反映。<br>缺点： —–<br>注意：使用动态原型模式时，不能使用对象字面量重写原型。因为，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的关系。</li></ul><ul><li>寄生构造模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    var o &#x3D; new Object()</span><br><span class="line">    o.name &#x3D; name</span><br><span class="line">    o.sayName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">    return o</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person(&quot;a&quot;)</span><br><span class="line">person.sayName() &#x2F;&#x2F; a</span><br></pre></td></tr></table></figure><p>优点：在上面的几种模式都不适用的时候，可以使用该方法。比如：创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，可以使用这个模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray() &#123;</span><br><span class="line">    var Array &#x3D; new Array()</span><br><span class="line">    arr.push.apply(array,arguments)</span><br><span class="line">    arr.toPipedString &#x3D; function()&#123;</span><br><span class="line">        return this.join(&quot;|&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return array</span><br><span class="line">&#125;</span><br><span class="line">colors &#x3D; new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)</span><br><span class="line">colors.toPipedString() &#x2F;&#x2F; &quot;red|blue|green&quot;</span><br></pre></td></tr></table></figure><p>缺点：无法使用instanceof来识别对象所属类型</p><ul><li>稳妥构造函数模式<br>稳妥对象：</li></ul><ul><li>没有公共属性，而且其方法也不引用this的对象</li><li>最合适在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。</li></ul><p>稳妥构造函数和寄生构造函数的区别：</p><ul><li>新创建对象的实例方法不引用this</li><li>不适用new操作符调用构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    var o&#x3D; new Object()</span><br><span class="line">    o.sayName &#x3D; function() &#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    retur o </span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">person.sayName()</span><br></pre></td></tr></table></figure>优点：非常适合在某些安全执行环境下使用<br>缺点：无法使用instance来识别对象所属类型</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Object构造函数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://weilonglong.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>morgan中间件记录日志</title>
    <link href="http://weilonglong.top/2020/07/25/morgan%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/"/>
    <id>http://weilonglong.top/2020/07/25/morgan%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</id>
    <published>2020-07-25T14:26:21.000Z</published>
    <updated>2020-08-24T12:49:10.091Z</updated>
    
    <content type="html"><![CDATA[<p>第一次使用node写接口，本以为只是简单的增删改查，将基本的增删改查之后，随着对后端的裂解，故想增加了记录日志。日志对于服务器的日常维护与问题回顾起着很大的作用，故自己完善这部分功能。</p><a id="more"></a><p>Express 框架使用 morgan 中间件记录日志，而且在 app.js 文件中已经默认引入了该中间件 var logger = require(‘morgan’);<br>使用 app.use(logger(‘dev’)); 可以将请求信息打印在控制台，便于开发调试，但实际生产环境中，通常需要将日志记录在日志文件里，<a href="https://www.npmjs.com/package/morgan" target="_blank" rel="noopener">morgan</a>的官方文档说明的非常详细。<a href="https://www.php.cn/js-tutorial-393516.html" target="_blank" rel="noopener">morgan</a>中文详解。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">var logger &#x3D; require(&#39;morgan&#39;);</span><br><span class="line"></span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create a write stream (in append mode) </span><br><span class="line">var accessLogStream &#x3D; fs.createWriteStream(__dirname + &#39;&#x2F;access.log&#39;, &#123;flags: &#39;a&#39;&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setup the logger </span><br><span class="line">app.use(logger(&#39;combined&#39;, &#123;stream: accessLogStream&#125;));</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">    res.send(&#39;hello, world!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><p>将日志按日期进行生成单个文件<br>安装file-stream-rotator<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var FileStreamRotator &#x3D; require(&#39;file-stream-rotator&#39;);</span><br><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">var logger &#x3D; require(&#39;morgan&#39;);</span><br><span class="line"></span><br><span class="line">var app &#x3D; express();</span><br><span class="line">var logDirectory &#x3D; __dirname + &#39;&#x2F;log&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ensure log directory exists </span><br><span class="line">fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create a rotating write stream </span><br><span class="line">var accessLogStream &#x3D; FileStreamRotator.getStream(&#123;</span><br><span class="line">    date_format: &#39;YYYYMMDD&#39;,</span><br><span class="line">    filename: logDirectory + &#39;&#x2F;%DATE%.log&#39;,</span><br><span class="line">    frequency: &#39;daily&#39;,</span><br><span class="line">    verbose: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setup the logger </span><br><span class="line">app.use(logger(&#39;combined&#39;, &#123;stream: accessLogStream&#125;));</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">    res.send(&#39;hello, world!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次使用node写接口，本以为只是简单的增删改查，将基本的增删改查之后，随着对后端的裂解，故想增加了记录日志。日志对于服务器的日常维护与问题回顾起着很大的作用，故自己完善这部分功能。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Sequelize" scheme="http://weilonglong.top/tags/Sequelize/"/>
    
      <category term="Express" scheme="http://weilonglong.top/tags/Express/"/>
    
      <category term="morgan" scheme="http://weilonglong.top/tags/morgan/"/>
    
      <category term="Node.js" scheme="http://weilonglong.top/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>常见代码手写部分</title>
    <link href="http://weilonglong.top/2020/07/25/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/"/>
    <id>http://weilonglong.top/2020/07/25/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/</id>
    <published>2020-07-25T14:24:44.000Z</published>
    <updated>2020-07-27T15:41:36.009Z</updated>
    
    <content type="html"><![CDATA[<ul><li>通用的事件侦听器函数</li></ul><a id="more"></a><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const EventUtils &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加事件</span><br><span class="line">    addEvent: function(element, type, handler)&#123;</span><br><span class="line">        if(element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type, handler, false)</span><br><span class="line">        &#125;else if(element.atachEvent) &#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot;+type, handler)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            element[&quot;on&quot;+type] &#x3D; handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 移除事件</span><br><span class="line">    romoveEvent: function(element, type, handler)&#123;</span><br><span class="line">        if(element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type, handler, false)</span><br><span class="line">        &#125;else if(element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot;+type,handler)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            element[&quot;on&quot;+type] &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取事件目标</span><br><span class="line">    getTarget: function(event) &#123;</span><br><span class="line">        return event.target || event.srcElement</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取event对象的引用，取到时间的所有所有信息，确保随时能使用event</span><br><span class="line">    getEvent: function(event)&#123;</span><br><span class="line">        return event || window.event</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻止事件（主要是事件冒泡，因为IE不支持时间捕获）</span><br><span class="line">    stopPropagation: function(event) &#123;</span><br><span class="line">        if(event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            event.cancelBubble &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 取消事件的默认行为</span><br><span class="line">    preventDefault: function(event) &#123;</span><br><span class="line">        if(event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            event.returnValue &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>高阶函数<br>高阶函数只是将函数作为参数或返回值的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function higerOrderFunction(param, callback)&#123;</span><br><span class="line">    return callback(params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动实现<code>Array.prototype.map</code>方法<br>map()方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function map(arr,mapCallback)&#123;</span><br><span class="line">    if(!Array.isArray(arr) || !arr.length || typeof mapCallback !&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        let result &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 每次调用此函数创建一个result数组。</span><br><span class="line">        &#x2F;&#x2F; 因为我们不想改变原始数组。</span><br><span class="line">        for(let i&#x3D;0; len&#x3D;arr.length; i &lt; len; i++)&#123;</span><br><span class="line">            result.push(mapCallback(arr[i], i, arr))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动实现<code>Array.prototype.filter</code>方法<br>filter方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function filter(arr, filterCallback)&#123;</span><br><span class="line">    if(!Array.isArray(arr) || !arr.length || typeof filterCallback !&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        let result &#x3D; [];</span><br><span class="line">        for (let i&#x3D; 0;len&#x3D;result.length; i&lt; len; i++)&#123;</span><br><span class="line">            if(filterCallback(arr[i],i,arr))&#123;</span><br><span class="line">                result.push(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动实现<code>Array.prototype.reduce</code>方法<br><a href="">reduce()</a>方法对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function reduce(arr, reduceCallBack, initialValue) &#123;</span><br><span class="line">    if(!Array.isArray(arr) || !arr.length || reduceCallBack !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let hasInitialValue &#x3D; initialValue !&#x3D;&#x3D; undefined</span><br><span class="line">        let value &#x3D; hasInitialValue ? initialValue : arr[0]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果有传递initialValue,则索引从1开始，否则从0开始</span><br><span class="line">        for (let i &#x3D; hasInitialValue ? 0 : 1,len&#x3D;arr.lrngth; i &lt; len; i++ )&#123;</span><br><span class="line">            value &#x3D; reduceCallback(value, arr[i], i, arr)</span><br><span class="line">        &#125;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;通用的事件侦听器函数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://weilonglong.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6新特性</title>
    <link href="http://weilonglong.top/2020/07/25/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://weilonglong.top/2020/07/25/ES6%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-07-25T14:24:11.000Z</published>
    <updated>2020-08-09T14:43:36.557Z</updated>
    
    <content type="html"><![CDATA[<ul><li>ES6新特性</li></ul><a id="more"></a><ul><li>块作用域</li><li>类</li><li>箭头函数</li><li>模板字符串</li><li>加强的对象字面</li><li>对象结构</li><li>Promise</li><li>模块</li><li>Symbol</li><li>代理（proxy）</li><li>Set</li><li>函数默认参数</li><li>rest和展开</li></ul><ul><li><p>‘var’，‘let’和‘const’的区别<br>var 声明的变量会挂载在window上。而let和const声明不会：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 100</span><br><span class="line">console.log(a, window.a) &#x2F;&#x2F; 100, 10</span><br><span class="line">let b &#x3D; 10;</span><br><span class="line">console.log(b, window.b) &#x2F;&#x2F; 10 undefined</span><br><span class="line">let c &#x3D; 1;</span><br><span class="line">console.log(c, window.c) &#x2F;&#x2F; 1 undefined</span><br></pre></td></tr></table></figure><p>var 声明的变量存在变量提升，let和const 不存在变量提升：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; undefiner &#x3D;&#x3D;&#x3D;&gt; a已经声明但还没赋值，默认得到undefined</span><br><span class="line">var a &#x3D; 100</span><br><span class="line"></span><br><span class="line">console.log(b) &#x2F;&#x2F; 报错：b is not defined &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br><span class="line">let b &#x3D; 10</span><br><span class="line"></span><br><span class="line">console.log(c) &#x2F;&#x2F; 报错：c is not defined &#x3D;&#x3D;&#x3D;&gt;找不到c这个变量、</span><br><span class="line">const c &#x3D; 1</span><br></pre></td></tr></table></figure><p>let 和 const 声明形成块作用域</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    if(true)&#123;</span><br><span class="line">        var a &#x3D; 100</span><br><span class="line">        let b &#x3D; 10</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a) &#x2F;&#x2F; 100</span><br><span class="line">    console.log(b) &#x2F;&#x2F; 报错：b is not defined &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br><span class="line">------------------------------------</span><br><span class="line">  if(true)&#123;</span><br><span class="line">        var a &#x3D; 100</span><br><span class="line">        const c &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a) &#x2F;&#x2F; 100</span><br><span class="line">    console.log(c) &#x2F;&#x2F; 报错：c is not defined &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br></pre></td></tr></table></figure><p>同一个作用域下let和const 不能声明同名变量 而var可以</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 100</span><br><span class="line">console.log(a) &#x2F;&#x2F; 100</span><br><span class="line">var a &#x3D; 10</span><br><span class="line">console.log(a) &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">let b &#x3D; 100</span><br><span class="line">let b &#x3D; 100</span><br><span class="line"></span><br><span class="line">报错 Identifier &#39;b&#39; has already been declared  &#x3D;&#x3D;&#x3D;&gt; 标识符b已经被声明了。</span><br></pre></td></tr></table></figure><p>暂时性死区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 100;</span><br><span class="line">if(true) &#123;</span><br><span class="line">    a &#x3D; 10;</span><br><span class="line">    &#x2F;&#x2F; 在当前块作用域中声明a使用let&#x2F;const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class="line">    &#x2F;&#x2F; 而这时，还未到声明时候，所以控制台 Error：a is not defined </span><br><span class="line">    let a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*   1. 一旦声明，必须赋值，不能使用null占位</span><br><span class="line">*   2. 声明后不能修改</span><br><span class="line">*   3. 如果生命的是复合类型数据，可以修改其属性</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><ul><li><p>箭头函数<br>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguemnts，suprt或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var getCurrentDate &#x3D; function ()&#123;</span><br><span class="line">    return new Date()</span><br><span class="line">&#125;</span><br><span class="line">const getCurrentDate &#x3D; () &#x3D;&gt; new Date()</span><br></pre></td></tr></table></figure><p>在本例中，ES5版本有function() {}声明和return关键字，这两个关键字分别是创建函数和返回值做需要的。在箭头函数版本中，我们只需要()括号，不需要return语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有隐式的返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES5 Version</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">return &#39;Hello &#39; + name + &#39;!&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES6 Version</span><br><span class="line">const greet &#x3D; (name) &#x3D;&gt; &#96;Hello $&#123;name&#125;&#96;;</span><br><span class="line">const greet2 &#x3D; name &#x3D;&gt; &#96;Hello $&#123;name&#125;&#96;;</span><br></pre></td></tr></table></figure><p>我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const getArgs &#x3D; () &#x3D;&gt; arguments</span><br><span class="line">const getArgs2 &#x3D; (...rest) &#x3D;&gt; rest</span><br></pre></td></tr></table></figure><p>箭头函数不能访问arguments对象。所以调用第一个getArgs函数会跑出一个错误。相反，我们使用rest参数来获得在箭头函数中传递的所有参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const data &#x3D; &#123;</span><br><span class="line">    result: 0,</span><br><span class="line">    nums: [1, 2, 3, 4, 5],</span><br><span class="line">    computeResult() &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的“this”指的是“data”对象</span><br><span class="line">        const addAll &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        return this.nums.reduce((total, cur) &#x3D;&gt; total + cur, 0)</span><br><span class="line">        &#125;;</span><br><span class="line">        this.result &#x3D; addAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。</p></li><li><p>什么是类<br>类（class）是在JS中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中仍然是原型和基于原型的继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Person(firstName, lastName, age, address)&#123;</span><br><span class="line">    this.firstName &#x3D; firstName</span><br><span class="line">    this.lastName &#x3D; lastName</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">    this.address &#x3D; address</span><br><span class="line">&#125;</span><br><span class="line">Person.self &#x3D; function()&#123;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"> Person.prototype.toString &#x3D; function()&#123;</span><br><span class="line">    return &quot;[object Person]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName &#x3D; function ()&#123;</span><br><span class="line">    return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 </span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(firstName, lastName, age, address)&#123;</span><br><span class="line">        this.firstName &#x3D; firstName</span><br><span class="line">        this.lastName &#x3D; lastName</span><br><span class="line">        this.age &#x3D; age</span><br><span class="line">        this.address &#x3D; address</span><br><span class="line">    &#125;</span><br><span class="line">    static self()&#123;</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return &quot;[Object Person]&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    getFullName()&#123;</span><br><span class="line">        return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写方法并从另一个类继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Employee.prototype &#x3D; Object.create(Person.prototype)</span><br><span class="line">function Employee(firstName, lastName, age, address, jobTitle, yearStart)&#123;</span><br><span class="line">    Person.call(this, firstName, lastName, age, address)</span><br><span class="line">    this.jobTitle &#x3D; jobTitle</span><br><span class="line">    this.yearStart &#x3D; yearStarted</span><br><span class="line">&#125;</span><br><span class="line">Employee.prototype.describe &#x3D; function () &#123;</span><br><span class="line">return &#96;I am $&#123;this.getFullName()&#125; and I have a position of $&#123;this.jobTitle&#125; and I started at $&#123;this.yearStarted&#125;&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype.toString &#x3D; function () &#123;</span><br><span class="line">return &quot;[object Employee]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 </span><br><span class="line">class Employee extends Person &#123; &#x2F;&#x2F;Inherits from &quot;Person&quot; class</span><br><span class="line">    constructor(firstName, lastName, age, address, jobTitle, yearStarted) &#123;</span><br><span class="line">        super(firstName, lastName, age, address);</span><br><span class="line">        this.jobTitle &#x3D; jobTitle;</span><br><span class="line">        this.yearStarted &#x3D; yearStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    describe() &#123;</span><br><span class="line">        return &#96;I am $&#123;this.getFullName()&#125; and I have a position of $&#123;this.jobTitle&#125; and I started at $&#123;this.yearStarted&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123; &#x2F;&#x2F; Overriding the &quot;toString&quot; method of &quot;Person&quot;</span><br><span class="line">            return &quot;[object Employee]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以我们要怎么知道它在内部使用原型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Something &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function AnotherSomething()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const as &#x3D; new AnotherSomething();</span><br><span class="line">const s &#x3D; new Something();</span><br><span class="line"></span><br><span class="line">console.log(typeof Something); &#x2F;&#x2F; &quot;function&quot;</span><br><span class="line">console.log(typeof AnotherSomething); &#x2F;&#x2F; &quot;function&quot;</span><br><span class="line">console.log(as.toString()); &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line">console.log(as.toString()); &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line">console.log(as.toString &#x3D;&#x3D;&#x3D; Object.prototype.toString); &#x2F;&#x2F; true</span><br><span class="line">console.log(s.toString &#x3D;&#x3D;&#x3D; Object.prototype.toString); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li><p>对象解构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const zhangsan &#x3D; &#123;</span><br><span class="line">    age:12,</span><br><span class="line">    sex:&quot;boy&quot;</span><br><span class="line">&#125;</span><br><span class="line">let &#123;age,sex&#125; &#x3D; zhangsan</span><br><span class="line">let &#123;age:age1,sex&#125; &#x3D; zhangsan &#x2F;&#x2F; 取别名 age为undefined,age1 为12</span><br><span class="line">let &#123; age, sex, hobby &#x3D; &quot;听歌&quot; &#125; &#x3D; zhangsan; &#x2F;&#x2F; 设置默认值，当其属性值为undefined，会使用默认值</span><br></pre></td></tr></table></figure></li><li><p>什么是’Set’对象，它是如何工作的？<br>Set对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>我们可以使用Set构建函数创建Set实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set1 &#x3D; new Set()</span><br><span class="line">const set2 &#x3D; new Set([1,2,3,3,3,4,4,5,6,6,7])</span><br></pre></td></tr></table></figure><p>我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的放法再次使用add。如果一个值已经存在于Set对象中，那么将不会被添加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set2.add(8)</span><br><span class="line">set2.add(9).add(10).add(10)</span><br><span class="line">&#x2F;&#x2F; 后面的10不会被添加到set对象中，因为它已经存在了。</span><br></pre></td></tr></table></figure><p>我们可以使用has方法检查Set实例中是否存在特定的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set2.has(5) &#x2F;&#x2F; true</span><br><span class="line">set2.has(13) &#x2F;&#x2F; fasle</span><br></pre></td></tr></table></figure><p>我们可以使用size属性获得Set实例的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set2.size &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p>我们可以使用Set对象删除数组中重复的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set2.clear()</span><br></pre></td></tr></table></figure><p>我们可以使用Set对象来删除数组中的重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1,2,3,3,4,4]</span><br><span class="line">const uniqueNums &#x3D; [...new Set(numbers)] &#x2F;&#x2F; [1,2,3,4]</span><br></pre></td></tr></table></figure><p>另外还有WeakSet，与Set类似，也是不重复的值的集合。但是WeakSet的成员只能是对象，而不能是其他类型的值。WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。</p><ol><li><p>Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象都可以当做键）。</p></li><li><p>WeakMap 结构与Map结构类似，也是用于生成键值对的集合。但是WeakMap只接受对象作为键名（null除外），不接收其他类型的值最为键名。而且WeakMap的键名所指向的对象，不计入垃圾回收机制。</p></li></ol></li></ul></li></ul><ul><li>Proxy<br>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。<br>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意识代理，用在这里表示由它来“代理某些操作，可以译为“代理器”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;ES6新特性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://weilonglong.top/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://weilonglong.top/tags/ES6/"/>
    
  </entry>
  
</feed>
