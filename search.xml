<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快速开启本地服务</title>
      <link href="/2020/08/22/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%90%AF%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/08/22/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%90%AF%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>在本地开发时,写html页面时经常会遇到需要开启本地服务,在其余电脑进行调试，或者进行手机查看效果的情况。<br>在这介绍两种。</p><h3 id="利用express-generator快速开启本地服务"><a href="#利用express-generator快速开启本地服务" class="headerlink" title="利用express-generator快速开启本地服务"></a>利用express-generator快速开启本地服务</h3><p>全局安装express-generator<br><code>npm i express-generator -g</code><br>创建项目<br><code>express  demo -e</code><br>-e的含义是使用ejs模板<br><code>cd demo</code><br><code>npm install</code><br>将文件放到public文件夹下,执行<code>npm run dev</code>默认3000端口即可访问</p><h3 id="在Vscode中安装Live-Server插件"><a href="#在Vscode中安装Live-Server插件" class="headerlink" title="在Vscode中安装Live Server插件"></a>在Vscode中安装Live Server插件</h3><p>在Vscode中搜索Live Server进行安装，将工作文件夹拖到工作区，或文件打开文件夹。右键点击Open with live server即可访问5500端口。<br>如在上次已经打开过项目，再进行开启项目时，开启不起来，右键点击stop live serve,重新开启即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 快速开启本地服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket.Io与express在http请求中发送消息初体验</title>
      <link href="/2020/08/22/Socket-Io%E4%B8%8Eexpress%E5%9C%A8http%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2020/08/22/Socket-Io%E4%B8%8Eexpress%E5%9C%A8http%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>网上基本出现的大多都是这种简单写法,并没有做一个深入的写，怎么进行在http请求中进行websocket的发送消息，近日，自己因为需求，因为不熟悉，走了很多弯路，故自己这次进行一下记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;); </span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">var server &#x3D; require(&#39;http&#39;).createServer(app);</span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;)(server);</span><br><span class="line"></span><br><span class="line">app.use(&#39;&#x2F;&#39;, express.static(__dirname + &#39;&#x2F;public&#39;)); </span><br><span class="line"></span><br><span class="line">server.listen(80);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;socket部分</span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">    &#x2F;&#x2F;接收并处理客户端的hi事件</span><br><span class="line">    socket.on(&#39;hi&#39;, function(data) &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;触发客户端事件c_hi</span><br><span class="line">        socket.emit(&#39;c_hi&#39;,&#39;hello too!&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;断开事件</span><br><span class="line">    socket.on(&#39;disconnect&#39;, function(data) &#123;</span><br><span class="line">    console.log(&#39;断开&#39;,data)</span><br><span class="line">        socket.emit(&#39;c_leave&#39;,&#39;离开&#39;);</span><br><span class="line">        &#x2F;&#x2F;socket.broadcast用于向整个网络广播(除自己之外)</span><br><span class="line">        &#x2F;&#x2F;socket.broadcast.emit(&#39;c_leave&#39;,&#39;某某人离开了&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种没有写怎么在http请求中怎么进行处理websocket消息。<br>基于Sequelize-cli生成的框架，其是又bin/www文件进行启动监听的，我们不进行修改，仍由www文件进行启动监听，但是app.js需<br>要修改。<br>app.js中新增以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;)(server);</span><br><span class="line"></span><br><span class="line">app.use(function(req, res, next)&#123;  </span><br><span class="line">  res.io &#x3D; io;  </span><br><span class="line">  next();  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">    &#x2F;&#x2F;接收并处理客户端的hi事件</span><br><span class="line">    socket.on(&#39;hi&#39;, function(data) &#123;</span><br><span class="line">        console.log(data);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;触发客户端事件c_hi</span><br><span class="line">        socket.emit(&#39;c_hi&#39;,&#39;hello too!&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;断开事件</span><br><span class="line">    socket.on(&#39;disconnect&#39;, function(data) &#123;</span><br><span class="line">      console.log(&#39;断开&#39;,data)</span><br><span class="line">        socket.emit(&#39;c_leave&#39;,&#39;离开&#39;);</span><br><span class="line">        &#x2F;&#x2F;socket.broadcast用于向整个网络广播(除自己之外)</span><br><span class="line">        &#x2F;&#x2F;socket.broadcast.emit(&#39;c_leave&#39;,&#39;某某人离开了&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">app.server&#x3D;server</span><br><span class="line">module.exports &#x3D; app;</span><br></pre></td></tr></table></figure><p>www文件进行删除相应的http，以及http.createServe()，并将所有的server更换为app.serve</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var app &#x3D; require(&#39;..&#x2F;app&#39;);</span><br><span class="line">var debug &#x3D; require(&#39;debug&#39;)(&#39;app:server&#39;);</span><br><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Get port from environment and store in Express.</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">var port &#x3D; normalizePort(process.env.PORT || &#39;5000&#39;);</span><br><span class="line">app.set(&#39;port&#39;, port);</span><br><span class="line">&#x2F;**</span><br><span class="line">* Create HTTP server.</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.server.listen(port);</span><br><span class="line">app.server.on(&#39;error&#39;, onError);</span><br><span class="line">app.server.on(&#39;listening&#39;, onListening);</span><br></pre></td></tr></table></figure><p>这样在router/index.js中即可进行对房间中的连接进行发送消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.get(&#39;&#x2F;:id&#39;, function (req, res, next) &#123;</span><br><span class="line">  res.io.emit(&#39;c_hi&#39;,&#123;code:1,data:&#39;data&#39;&#125;)</span><br><span class="line">  res.send(&#123;code:1,data:&#39;data&#39;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;ul id&#x3D;&quot;message&quot;&gt;&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    </span><br><span class="line">    socket &#x3D; io.connect(&#39;ws:&#x2F;&#x2F;127.0.0.1:5000&#39;);</span><br><span class="line"></span><br><span class="line">    socket.emit(&quot;message&quot;, &#123;&quot;name&quot; : navigator.userAgent, room:&#39;1&#39;, &quot;msg&quot; : &quot;hello world&quot;&#125;);</span><br><span class="line"></span><br><span class="line">    socket.on(&quot;message&quot;, function(obj) &#123;</span><br><span class="line"></span><br><span class="line">      console.log(obj);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>大功告成</p>]]></content>
      
      
      
        <tags>
            
            <tag> Express </tag>
            
            <tag> Socket.Io </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>border-radius的简写</title>
      <link href="/2020/08/19/border-radius%E7%9A%84%E7%AE%80%E5%86%99/"/>
      <url>/2020/08/19/border-radius%E7%9A%84%E7%AE%80%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>border-radius一般在实际使用的时候一般是画小圆角或者弧度，弧度花的话一般也是四个角一起画，两个角画会响应减少，两个角的弧度不一致更在实际的需求会少很多,就算一个角有特殊需求，也可以单独进行设置。</p><p>border-radius在实际的使用中还是很多的，在最一开始学的时候记住了简写，没有深入的学习,虽然会写，但是复杂的带/的没弄懂什么意思，今天学习一下。<br><code>border-radius:2px;</code><br>等价于的语句是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-top-left-radius:2px 2px;</span><br><span class="line">border-top-right-raduis:2px 2px;</span><br><span class="line">border-bottom-right-raduis:2px 2px;</span><br><span class="line">border-bottom-left-radius:2px 2px;</span><br></pre></td></tr></table></figure><p>为什么这两个是等价的呢。<br>在菜鸟教程文档中,border-radius的标准简写是这样的<br><code>border-radius: 1-4 length|% / 1-4 length|%;</code><br><code>注意: 每个半径的四个值的顺序是：左上角，右上角，右下角，左下角。如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的。</code></p><p>归根于这句话。<br>之前的那种写法都是省略过的，如果补全是这样的。<br><code>border-radius:2px 2px 2px 2px/2px 2px 2px 2px;</code></p><p>这里边有一个重点，即如果省略左下角，右上角是相同的。如果省略右下角，左上角是相同的。如果省略右上角，左上角是相同的；如果你使用省略写法的话,单独一个角没有圆角时，必须记得设置为0，那么其会与之相匹配的角一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 2em 1em 4em &#x2F; 0.5em 3em;</span><br><span class="line"></span><br><span class="line">is equivalent to:</span><br><span class="line"></span><br><span class="line">border-top-left-radius: 2em 0.5em;</span><br><span class="line">border-top-right-radius: 1em 3em;</span><br><span class="line">border-bottom-right-radius: 4em 0.5em;</span><br><span class="line">border-bottom-left-radius: 1em 3em;</span><br></pre></td></tr></table></figure><p>在上边的”/“前面是圆角的水平半径，”/“后面是圆角的垂直半径。<br>这样也就理解了上边的等价是什么意思。<br>其补充完是这样的<br><code>border-radius: 2em 1em 4em 1em/ 0.5em 3em 0.5em 3em;</code><br>这样再去看其相等就一眼看明白了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端无痛刷新token</title>
      <link href="/2020/08/17/%E5%89%8D%E7%AB%AF%E6%97%A0%E7%97%9B%E5%88%B7%E6%96%B0token/"/>
      <url>/2020/08/17/%E5%89%8D%E7%AB%AF%E6%97%A0%E7%97%9B%E5%88%B7%E6%96%B0token/</url>
      
        <content type="html"><![CDATA[<p>两种方案，第一种记录登录时间，根据后台设置的token过期时间，进行在时间内请求更换token<br>第二种利用axios的拦截，在返回token过期时，那么token去更换token，再用新的token去请求数据。<br>第二种，上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">import &#123; Message &#125; from &#39;element-ui&#39;</span><br><span class="line">import store from &#39;@&#x2F;store&#39;</span><br><span class="line">import &#123; getToken &#125; from &#39;@&#x2F;utils&#x2F;auth&#39;</span><br><span class="line"></span><br><span class="line">var isRefreshing &#x3D; false</span><br><span class="line">var requests &#x3D; []</span><br><span class="line">&#x2F;&#x2F; create an axios instance</span><br><span class="line">const service &#x3D; axios.create(&#123;</span><br><span class="line">  baseURL: process.env.VUE_APP_BASE_API,</span><br><span class="line">  timeout: 5000 &#x2F;&#x2F; request timeout</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; request interceptor</span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  config &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (store.getters.token) &#123;</span><br><span class="line">      config.headers[&#39;Authorization&#39;] &#x3D; &#39;Bearer &#39; + getToken()</span><br><span class="line">    &#125;</span><br><span class="line">    return config</span><br><span class="line">  &#125;,</span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line">    console.log(error) &#x2F;&#x2F; for debug</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; response interceptor</span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * If you want to get http information such as headers or status</span><br><span class="line">   * Please return  response &#x3D;&gt; response</span><br><span class="line">  *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Determine the request status by custom code</span><br><span class="line">   * Here is just an example</span><br><span class="line">   * You can also judge the status by HTTP Status Code</span><br><span class="line">   *&#x2F;</span><br><span class="line">  response &#x3D;&gt; &#123;</span><br><span class="line">    const res &#x3D; response.data</span><br><span class="line">    console.log(res, &#39;response.data&#39;)</span><br><span class="line">    if (res.code &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">      return res</span><br><span class="line">    &#125; else if (res.code &#x3D;&#x3D;&#x3D; 50008 || res.code &#x3D;&#x3D;&#x3D; 50012 || res.code &#x3D;&#x3D;&#x3D; 50014) &#123;</span><br><span class="line">      const config &#x3D; response.config</span><br><span class="line">      if (!isRefreshing) &#123;</span><br><span class="line">        isRefreshing &#x3D; true</span><br><span class="line">        return store.dispatch(&#39;user&#x2F;resetToken&#39;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">          const token &#x3D; res</span><br><span class="line">          config.headers[&#39;Authorization&#39;] &#x3D; token</span><br><span class="line">          config.baseURL &#x3D; &#39;&#39; &#x2F;&#x2F; url已经带上了&#x2F;api，避免出现&#x2F;api&#x2F;api的情况</span><br><span class="line">          requests.forEach(item &#x3D;&gt; item(token))</span><br><span class="line">          requests &#x3D; []</span><br><span class="line">          &#x2F;&#x2F; 重试当前请求并返回promise</span><br><span class="line">          &#x2F;&#x2F; console.log(service(config), &#39;service(config)&#39;)</span><br><span class="line">          return service(config)</span><br><span class="line">        &#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">          console.log(err)</span><br><span class="line">          &#x2F;&#x2F; console.error(&#39;refreshtoken error &#x3D;&gt;&#39;, res)</span><br><span class="line">          &#x2F;&#x2F; 刷新token失败，神仙也救不了了，跳转到首页重新登录吧</span><br><span class="line">          window.location.href &#x3D; &#39;&#x2F;&#39;</span><br><span class="line">        &#125;).finally(() &#x3D;&gt; &#123;</span><br><span class="line">          isRefreshing &#x3D; false</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span><br><span class="line">          requests.push((token) &#x3D;&gt; &#123;</span><br><span class="line">            config.baseURL &#x3D; &#39;&#39;</span><br><span class="line">            config.headers[&#39;Authorization&#39;] &#x3D; token</span><br><span class="line">            resolve(service(config))</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      Message(&#123;</span><br><span class="line">        message: res.message,</span><br><span class="line">        type: &#39;error&#39;,</span><br><span class="line">        duration: 5 * 1000</span><br><span class="line">      &#125;)</span><br><span class="line">      return Promise.reject(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default service</span><br></pre></td></tr></table></figure><p>思路,<br>当后端返回无权限时，将请求先保存下来，return一个Promise,利用Promise去刷新token,当请求token成功,拿着心得token,拿着存的config，去再次请求，成功后reslove()<br>这时带来了一个问题，就是当多次请求时,会多次refresh_token<br>设置一个状态值，用于记录是否正在刷新token。<br>如果正在刷新token，将其利用Promise，将其封装为一个函数,内部自动调用resolve,存入一个数组，等到刷新token后，执行存入的函数,执行resolve(),然后依次来再次请求数据，返回正确的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 我们先看一下，定义fn1</span><br><span class="line">function fn1 () &#123;</span><br><span class="line">    console.log(&#39;执行fn1&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行fn1,只需后面加个括号</span><br><span class="line">fn1()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回归到我们request数组中，每一项其实存的就是一个类似fn1的一个函数</span><br><span class="line">const fn2 &#x3D; (token) &#x3D;&gt; &#123;</span><br><span class="line">    config.headers[&#39;X-Token&#39;] &#x3D; token</span><br><span class="line">    resolve(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 我们要执行fn2，也只需在后面加个括号就可以了</span><br><span class="line">fn2()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于requests是一个数组，所以我们想遍历执行里面的所有的项，所以用上了forEach</span><br><span class="line">requests.forEach(fn &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 执行fn</span><br><span class="line">  fn()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> token </tag>
            
            <tag> Axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长时间无操作退出登录，返回登录页</title>
      <link href="/2020/08/16/%E9%95%BF%E6%97%B6%E9%97%B4%E6%97%A0%E6%93%8D%E4%BD%9C%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%99%BB%E5%BD%95%E9%A1%B5/"/>
      <url>/2020/08/16/%E9%95%BF%E6%97%B6%E9%97%B4%E6%97%A0%E6%93%8D%E4%BD%9C%E9%80%80%E5%87%BA%E7%99%BB%E5%BD%95%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%99%BB%E5%BD%95%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>先上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      interval: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    localStorage.setItem(&#39;lastTime&#39;, new Date().getTime())</span><br><span class="line">    this.addOn()</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    window.clearInterval(this.interval)</span><br><span class="line">&#125;,</span><br><span class="line"> methods: &#123;</span><br><span class="line">    addOn() &#123;</span><br><span class="line">      var lastTime &#x3D; new Date().getTime()</span><br><span class="line">      var currentTime &#x3D; new Date().getTime()</span><br><span class="line">      var timeOut &#x3D; 30 * 60 * 1000; &#x2F;&#x2F; 设置超时时间： 30分</span><br><span class="line"></span><br><span class="line">      window.document.onmousedown &#x3D; function() &#123;</span><br><span class="line">        localStorage.setItem(&#39;lastTime&#39;, new Date().getTime())</span><br><span class="line">      &#125;</span><br><span class="line">      function checkTimeout() &#123;</span><br><span class="line">        currentTime &#x3D; new Date().getTime() &#x2F;&#x2F; 更新当前时间</span><br><span class="line">        lastTime &#x3D; localStorage.getItem(&#39;lastTime&#39;)</span><br><span class="line">        if (currentTime - lastTime &gt; timeOut) &#123; &#x2F;&#x2F; 判断是否超时</span><br><span class="line">          var url &#x3D; window.location.href</span><br><span class="line">          var newUrl &#x3D; url.match(&#x2F;(\S*)#&#x2F;)[1]</span><br><span class="line">          removeToken()</span><br><span class="line">          window.open(newUrl + &#39;#&#x2F;login&#39;, &#39;_self&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;* 定时器 间隔30秒检测是否长时间未操作页面 *&#x2F;</span><br><span class="line">      this.interval &#x3D; window.setInterval(checkTimeout, 30*1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该页面时Layout布局中的,login页面是不引用的,<br>思路,在该页面mounted时设置一个时间，增加一个监听事件<br>每按下鼠标时，更新一次时间<br>每隔30s判断一次上次按下鼠标据现在时间间隔,如果超过了30分钟，清空定时器<br>清空token,将其返回到登录页面。<br>那么beforeDestroy()中是为了人为操作退出登录，然后清空定时器</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JaveScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sequelize-cli中新增列和删除列</title>
      <link href="/2020/08/13/Sequelize-cli%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%88%97%E5%92%8C%E5%88%A0%E9%99%A4%E5%88%97/"/>
      <url>/2020/08/13/Sequelize-cli%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%88%97%E5%92%8C%E5%88%A0%E9%99%A4%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>之前处于来发的时候，都是将数据表删除，将Sequlize迁移记录表中的记录进行删除，然后进行运行迁移，生成数据表，现在项目已经跑起来了，不能再这样操作了，否则会造成数据丢失。故寻找执行其迁移文件的增加列方法。<br>第一步执行命令<br><code>sequelize migration：create --name name_of_your_migration</code><br>或者自己手动新建.js文件<br>进行修改js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">up: (queryInterface, Sequelize) &#x3D;&gt; &#123;</span><br><span class="line">    return queryInterface.addColumn(</span><br><span class="line">        &#39;Storagelists&#39;,  &#x2F;&#x2F; 表名</span><br><span class="line">        &#39;name&#39;, &#x2F;&#x2F; 列名</span><br><span class="line">        Sequelize.TEXT &#x2F;&#x2F; 数据类型</span><br><span class="line">    );</span><br><span class="line">&#125;,</span><br><span class="line">down: (queryInterface, Sequelize) &#x3D;&gt; &#123;</span><br><span class="line">    return queryInterface.removeColumn(</span><br><span class="line">        &#39;Storagelists&#39;, &#x2F;&#x2F; 要执行的表名</span><br><span class="line">        &#39;deletename&#39; &#x2F;&#x2F; 删除的列名</span><br><span class="line">    ); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行迁移命令<br><code>sequleize db:migrate</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Sequelize-cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-cli项目使用CDN优化Element-ui打包体积太大问题</title>
      <link href="/2020/08/11/Vue-cli%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8MDN%E5%8A%A0%E9%80%9FElement-ui/"/>
      <url>/2020/08/11/Vue-cli%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8MDN%E5%8A%A0%E9%80%9FElement-ui/</url>
      
        <content type="html"><![CDATA[<p>Vue-cli生成的单页面,引入Element-ui后打包后js，css大，服务器带宽小，首屏渲染速度慢，进行优化的方案之一即是MDN加速。<br>在index.html中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;element-ui&#x2F;2.7.2&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>修改main.js,将引入Element以及Use注释删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; import ElementUI from &#39;element-ui&#39;</span><br><span class="line">&#x2F;&#x2F; import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line">&#x2F;&#x2F; Vue.use(ElementUI)</span><br></pre></td></tr></table></figure><p>修改vue.config.js,增加此段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: &#123;</span><br><span class="line">    externals: &#123;</span><br><span class="line">        &#39;vue&#39;: &#39;Vue&#39;,</span><br><span class="line">        &#39;element-ui&#39;: &#39;ELEMENT&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成</p>]]></content>
      
      
      
        <tags>
            
            <tag> MDN优化 </tag>
            
            <tag> Element-ui性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在vue中使用screen-full全屏</title>
      <link href="/2020/08/08/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8screen-full%E5%85%A8%E5%B1%8F/"/>
      <url>/2020/08/08/%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8screen-full%E5%85%A8%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save screenfull</span><br></pre></td></tr></table></figure><p>封装为组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;svg-icon :icon-class&#x3D;&quot;isFullscreen?&#39;exit-fullscreen&#39;:&#39;fullscreen&#39;&quot; @click&#x3D;&quot;click&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import screenfull from &#39;screenfull&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">name: &#39;Screenfull&#39;,</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">    isFullscreen: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.init()</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">    this.destroy()</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    click() &#123;</span><br><span class="line">    if (!screenfull.enabled) &#123;</span><br><span class="line">        this.$message(&#123;</span><br><span class="line">        message: &#39;you browser can not work&#39;,</span><br><span class="line">        type: &#39;warning&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    screenfull.toggle()</span><br><span class="line">    &#125;,</span><br><span class="line">    change() &#123;</span><br><span class="line">    this.isFullscreen &#x3D; screenfull.isFullscreen</span><br><span class="line">    &#125;,</span><br><span class="line">    init() &#123;</span><br><span class="line">    if (screenfull.enabled) &#123;</span><br><span class="line">        screenfull.on(&#39;change&#39;, this.change)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    destroy() &#123;</span><br><span class="line">    if (screenfull.enabled) &#123;</span><br><span class="line">        screenfull.off(&#39;change&#39;, this.change)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.screenfull-svg &#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">cursor: pointer;</span><br><span class="line">fill: #5a5e66;;</span><br><span class="line">width: 20px;</span><br><span class="line">height: 20px;</span><br><span class="line">vertical-align: 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><ul><li>在需要使用的页面中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;screenfull id&#x3D;&quot;screenfull&quot; class&#x3D;&quot;right-menu-item hover-effect&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">import Screenfull from &#39;@&#x2F;components&#x2F;Screenfull&#39;</span><br><span class="line"></span><br><span class="line">components: &#123;</span><br><span class="line">    Screenfull</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> screenfull </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用bat文件快速启动vue项目</title>
      <link href="/2020/08/05/%E4%BD%BF%E7%94%A8bat%E6%96%87%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8vue%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/08/05/%E4%BD%BF%E7%94%A8bat%E6%96%87%E4%BB%B6%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8vue%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="单项目"><a href="#单项目" class="headerlink" title="单项目"></a>单项目</h3><p>例如需启动”d/vue”下的项目<br>新建run.text,写入以下内容，修改后缀名为.bat,双击运行项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:: nodejs安装目录下的nodevars.bat</span><br><span class="line">set nodevars &#x3D; &quot;C:\Program Files\nodejs\nodevars.bat&quot;</span><br><span class="line">:: 切换到D盘</span><br><span class="line">d:</span><br><span class="line">:: 移动到需要启动的目录</span><br><span class="line">cd vue</span><br><span class="line">:: 启动项目</span><br><span class="line">cmd &#x2F;c %nodevars%&amp;&amp;npm run dev</span><br></pre></td></tr></table></figure><h3 id="可能多项目情况下"><a href="#可能多项目情况下" class="headerlink" title="可能多项目情况下"></a>可能多项目情况下</h3><p>如果在vue文件下有多个项目，可通过输入项目文件夹进行启动<br>例如 “d/vue/project1”,”d/vue/project2”项目,<br>可输入project1或者project2<br>如果运行项目直接回车，或者输入y/Y回车<br>如果只需要node环境，则输入n/N回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set nodevars &#x3D; &quot;C:\Program Files\nodejs\nodevars.bat&quot;</span><br><span class="line">:: 切换到D盘</span><br><span class="line">d:</span><br><span class="line">:: 移动到工作目录</span><br><span class="line">cd vue</span><br><span class="line">:: 中文提示会乱码</span><br><span class="line">echo Run Node.js command Or Npm run dev.</span><br><span class="line">set&#x2F;p option&#x3D;Enter project name:</span><br><span class="line">cd %option%</span><br><span class="line">set&#x2F;p keep&#x3D;Need &#39;Npm run dev&#39;?(y&#x2F;n)</span><br><span class="line">:: 区分输入指令</span><br><span class="line">set dev&#x3D;0</span><br><span class="line">if &quot;%keep%&quot;&#x3D;&#x3D;&quot;y&quot; (</span><br><span class="line">    set dev&#x3D;1</span><br><span class="line">) else if &quot;%keep%&quot;&#x3D;&#x3D;&quot;Y&quot; (</span><br><span class="line">    set dev&#x3D;2</span><br><span class="line">) else if &quot;%keep%&quot;&#x3D;&#x3D;&quot;&quot; (</span><br><span class="line">    set dev&#x3D;3</span><br><span class="line">) else if &quot;%keep%&quot;&#x3D;&#x3D;&quot;n&quot; (</span><br><span class="line">    set dev&#x3D;-1</span><br><span class="line">) else if &quot;%keep%&quot;&#x3D;&#x3D;&quot;N&quot; (</span><br><span class="line">    set dev &#x3D; -2</span><br><span class="line">)</span><br><span class="line">:: 运行程序</span><br><span class="line">if %dev% gtr 0 (</span><br><span class="line">    start cmd &#x2F;c %nodevars%&amp;&amp;npm run dev</span><br><span class="line">) else (</span><br><span class="line">    start cmd &#x2F;k %nodevars%</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="多项目-多任务"><a href="#多项目-多任务" class="headerlink" title="多项目,多任务"></a>多项目,多任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">echo 1</span><br><span class="line">@echo off</span><br><span class="line">@rem &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">:menu</span><br><span class="line">e:</span><br><span class="line">cls</span><br><span class="line"></span><br><span class="line">echo.</span><br><span class="line">:choseDir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  选择项目目录 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo.</span><br><span class="line">echo                       1:    \atest&#x2F;webpack1</span><br><span class="line">echo                       2:    \net-tj-EL-ZRZS-Front-master\EL-ZRZS-Front21</span><br><span class="line">echo                       3:    compass-project</span><br><span class="line">echo                       4:    yeoman-project </span><br><span class="line">echo.</span><br><span class="line">echo                       P:    ??Git??????</span><br><span class="line">echo                       Q:    ??</span><br><span class="line">echo.</span><br><span class="line">echo              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 选择项目目录 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo.</span><br><span class="line">set&#x2F;p option&#x3D;Enter project path:</span><br><span class="line">if &quot;%option%&quot;&#x3D;&#x3D;&quot;1&quot; (</span><br><span class="line">    cd &quot;atest&#x2F;webpack1&quot;</span><br><span class="line">)else if &quot;%option%&quot;&#x3D;&#x3D;&quot;2&quot; (</span><br><span class="line">    cd &quot;net-tj-EL-ZRZS-Front-master\EL-ZRZS-Front21&quot;</span><br><span class="line">)else if &quot;%option%&quot;&#x3D;&#x3D;&quot;&quot; (</span><br><span class="line">    cd &quot;net-tj-EL-ZRZS-Front-master\EL-ZRZS-Front21&quot;</span><br><span class="line">)else if &quot;%option%&quot;&#x3D;&#x3D;&quot;9&quot; (</span><br><span class="line">    goto gofirst</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:dosomething</span><br><span class="line">echo.</span><br><span class="line">echo              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  你想干什么 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo.</span><br><span class="line">echo1:   运行项目</span><br><span class="line">echo2:   打包</span><br><span class="line">echo3：  执行EsLint验证</span><br><span class="line">echo.</span><br><span class="line">echo.</span><br><span class="line">echo9:   返回上一级</span><br><span class="line">echo.</span><br><span class="line">echo              &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 你想干什么 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">echo.</span><br><span class="line">set&#x2F;p option1&#x3D;Enter dosomething(1&#x2F;2):</span><br><span class="line">    if &quot;%option1%&quot;&#x3D;&#x3D;&quot;&quot; (</span><br><span class="line">        start cmd &#x2F;c %nodevars%&amp;&amp;npm run dev</span><br><span class="line">    )else if &quot;%option1%&quot;&#x3D;&#x3D;&quot;1&quot; (</span><br><span class="line">        start cmd &#x2F;c %nodevars%&amp;&amp;npm run dev</span><br><span class="line">    ) else if &quot;%option1%&quot;&#x3D;&#x3D;&quot;2&quot; (</span><br><span class="line">        start cmd &#x2F;c %nodevars%&amp;&amp;npm run build:prod</span><br><span class="line">    ) else if &quot;%option1%&quot;&#x3D;&#x3D;&quot;9&quot; (</span><br><span class="line">    goto gofirst</span><br><span class="line">    ) else if &quot;%option1%&quot;&#x3D;&#x3D;&quot;3&quot; (</span><br><span class="line">    start cmd &#x2F;c %nodevars%&amp;&amp;npm run lint</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">:gofirst</span><br><span class="line"></span><br><span class="line">cd..</span><br><span class="line">cd..</span><br><span class="line">cd..</span><br><span class="line"></span><br><span class="line">goto choseDir</span><br></pre></td></tr></table></figure><p>最后效果<br><img src= "/img/loading.gif" data-src="dosDemo.png" alt="Image text"><br>注意事项：中文乱码情况下，以记事本打开另存为ANSI格式</p>]]></content>
      
      
      
        <tags>
            
            <tag> DOS命令 </tag>
            
            <tag> 批处理脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端常用正则库</title>
      <link href="/2020/08/03/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E5%BA%93/"/>
      <url>/2020/08/03/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="是否合法IP地址"><a href="#是否合法IP地址" class="headerlink" title="是否合法IP地址"></a>是否合法IP地址</h3><p>export function validateIP(rule, value, callback) {<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    const reg = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的IP地址’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否手机号码或者固话"><a href="#是否手机号码或者固话" class="headerlink" title="是否手机号码或者固话"></a>是否手机号码或者固话</h3><p>export function validatePhoneTwo(rule, value, callback) {<br>  const reg = /^((0\d{2,3}-\d{7,8})|(1[34578]\d{9}))$/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的电话号码或者固话号码’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否固话"><a href="#是否固话" class="headerlink" title="是否固话"></a>是否固话</h3><p>export function validateTelphone(rule, value, callback) {<br>  const reg = /0\d{2}-\d{7,8}/<br>  if (value === ‘’ || value === undefined || value === null) {<br>    callback()<br>  } else {<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的固话（格式：区号+号码,如010-1234567）’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否手机号码"><a href="#是否手机号码" class="headerlink" title="是否手机号码"></a>是否手机号码</h3><p>export function validatePhone(rule, value, callback) {<br>  const reg = /^[1][3,4,5,7,8][0-9]{9}$/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的电话号码’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否身份证号码"><a href="#是否身份证号码" class="headerlink" title="是否身份证号码"></a>是否身份证号码</h3><p>export function validateIdNo(rule, value, callback) {<br>  const reg = /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if ((!reg.test(value)) &amp;&amp; value !== ‘’) {<br>      callback(new Error(‘请输入正确的身份证号码’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="是否邮箱"><a href="#是否邮箱" class="headerlink" title="是否邮箱"></a>是否邮箱</h3><p>export function validateEMail(rule, value, callback) {<br>  const reg = /^([a-zA-Z0-9]+[-_.]?)+@[a-zA-Z0-9]+.[a-z]+$/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if (!reg.test(value)) {<br>      callback(new Error(‘请输入正确的邮箱地址’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="合法uri"><a href="#合法uri" class="headerlink" title="合法uri"></a>合法uri</h3><p>export function validateURL(textval) {<br>  const urlregex = /^(https?|ftp)://([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&amp;%$-]+)<em>@)</em>((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+.)<em>[a-zA-Z0-9-]+.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]+)</em>(/($|[a-zA-Z0-9.,?’\+&amp;%$#=~_-]+))*$/<br>  return urlregex.test(textval)<br>}</p><h3 id="验证内容是否英文数字以及下划线"><a href="#验证内容是否英文数字以及下划线" class="headerlink" title="验证内容是否英文数字以及下划线"></a>验证内容是否英文数字以及下划线</h3><p>export function isPassword(rule, value, callback) {<br>  const reg = /^[_a-zA-Z0-9]+$/<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else {<br>    if (!reg.test(value)) {<br>      callback(new Error(‘密码仅由英文字母，数字以及下划线组成’))<br>    } else {<br>      callback()<br>    }<br>  }<br>}</p><h3 id="自动检验数值的范围"><a href="#自动检验数值的范围" class="headerlink" title="自动检验数值的范围"></a>自动检验数值的范围</h3><p>export function checkMax20000(rule, value, callback) {<br>  if (value === ‘’ || value === undefined || value == null) {<br>    callback()<br>  } else if (!Number(value)) {<br>    callback(new Error(‘请输入[1,20000]之间的数字’))<br>  } else if (value &lt; 1 || value &gt; 20000) {<br>    callback(new Error(‘请输入[1,20000]之间的数字’))<br>  } else {<br>    callback()<br>  }<br>}</p><h3 id="验证数字输入框最大数值-32767"><a href="#验证数字输入框最大数值-32767" class="headerlink" title="验证数字输入框最大数值,32767"></a>验证数字输入框最大数值,32767</h3><p>export function checkMaxVal(rule, value, callback) {<br>  if (value &lt; 0 || value &gt; 32767) {<br>    callback(new Error(‘请输入[0,32767]之间的数字’))<br>  } else {<br>    callback()<br>  }<br>}</p><h3 id="验证是否1-99之间"><a href="#验证是否1-99之间" class="headerlink" title="验证是否1-99之间"></a>验证是否1-99之间</h3><p>export function isOneToNinetyNine(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入正整数’))<br>    } else {<br>      const re = /^[1-9][0-9]{0,1}$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入正整数，值为【1,99】’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 0)<br>}</p><h3 id="验证是否整数"><a href="#验证是否整数" class="headerlink" title="验证是否整数"></a>验证是否整数</h3><p>export function isInteger(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入正整数’))<br>    } else {<br>      const re = /^[0-9]<em>[1-9][0-9]</em>$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入正整数’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 0)<br>}</p><h3 id="验证是否整数-非必填"><a href="#验证是否整数-非必填" class="headerlink" title="验证是否整数,非必填"></a>验证是否整数,非必填</h3><p>export function isIntegerNotMust(rule, value, callback) {<br>  if (!value) {<br>    callback()<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入正整数’))<br>    } else {<br>      const re = /^[0-9]<em>[1-9][0-9]</em>$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入正整数’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 1000)<br>}</p><h3 id="验证是否是-0-1-的小数"><a href="#验证是否是-0-1-的小数" class="headerlink" title="验证是否是[0-1]的小数"></a>验证是否是[0-1]的小数</h3><p>export function isDecimal(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入[0,1]之间的数字’))<br>    } else {<br>      if (value &lt; 0 || value &gt; 1) {<br>        callback(new Error(‘请输入[0,1]之间的数字’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证是否是-1-10-的小数-即不可以等于0"><a href="#验证是否是-1-10-的小数-即不可以等于0" class="headerlink" title="验证是否是[1-10]的小数,即不可以等于0"></a>验证是否是[1-10]的小数,即不可以等于0</h3><p>export function isBtnOneToTen(rule, value, callback) {<br>  if (typeof value === ‘undefined’) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入正整数，值为[1,10]’))<br>    } else {<br>      if (!(value === ‘1’ || value === ‘2’ || value === ‘3’ || value === ‘4’ || value === ‘5’ || value === ‘6’ || value === ‘7’ || value === ‘8’ || value === ‘9’ || value === ‘10’)) {<br>        callback(new Error(‘请输入正整数，值为[1,10]’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证是否是-1-100-的小数-即不可以等于0"><a href="#验证是否是-1-100-的小数-即不可以等于0" class="headerlink" title="验证是否是[1-100]的小数,即不可以等于0"></a>验证是否是[1-100]的小数,即不可以等于0</h3><p>export function isBtnOneToHundred(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入整数，值为[1,100]’))<br>    } else {<br>      if (value &lt; 1 || value &gt; 100) {<br>        callback(new Error(‘请输入整数，值为[1,100]’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证是否是-0-100-的小数"><a href="#验证是否是-0-100-的小数" class="headerlink" title="验证是否是[0-100]的小数"></a>验证是否是[0-100]的小数</h3><p>export function isBtnZeroToHundred(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (!Number(value)) {<br>      callback(new Error(‘请输入[1,100]之间的数字’))<br>    } else {<br>      if (value &lt; 0 || value &gt; 100) {<br>        callback(new Error(‘请输入[1,100]之间的数字’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证端口是否在-0-65535-之间"><a href="#验证端口是否在-0-65535-之间" class="headerlink" title="验证端口是否在[0,65535]之间"></a>验证端口是否在[0,65535]之间</h3><p>export function isPort(rule, value, callback) {<br>  if (!value) {<br>    return callback(new Error(‘输入不可以为空’))<br>  }<br>  setTimeout(() =&gt; {<br>    if (value === ‘’ || typeof (value) === undefined) {<br>      callback(new Error(‘请输入端口值’))<br>    } else {<br>      const re = /^([0-9]|[1-9]\d|[1-9]\d{2}|[1-9]\d{3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入在[0-65535]之间的端口值’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="验证端口是否在-0-65535-之间，非必填-isMust表示是否必填"><a href="#验证端口是否在-0-65535-之间，非必填-isMust表示是否必填" class="headerlink" title="验证端口是否在[0,65535]之间，非必填,isMust表示是否必填"></a>验证端口是否在[0,65535]之间，非必填,isMust表示是否必填</h3><p>export function isCheckPort(rule, value, callback) {<br>  if (!value) {<br>    callback()<br>  }<br>  setTimeout(() =&gt; {<br>    if (value === ‘’ || typeof (value) === undefined) {<br>      // callback(new Error(‘请输入端口值’));<br>    } else {<br>      const re = /^([0-9]|[1-9]\d|[1-9]\d{2}|[1-9]\d{3}|[1-5]\d{4}|6[0-4]\d{3}|65[0-4]\d{2}|655[0-2]\d|6553[0-5])$/<br>      const rsCheck = re.test(value)<br>      if (!rsCheck) {<br>        callback(new Error(‘请输入在[0-65535]之间的端口值’))<br>      } else {<br>        callback()<br>      }<br>    }<br>  }, 100)<br>}</p><h3 id="小写字母"><a href="#小写字母" class="headerlink" title="小写字母"></a>小写字母</h3><p>export function validateLowerCase(str) {<br>  const reg = /^[a-z]+$/<br>  return reg.test(str)<br>}</p><h3 id="验证key"><a href="#验证key" class="headerlink" title="验证key"></a>验证key</h3><p>// export function validateKey(str) {<br>//     var reg = /^[a-z_-:]+$/;<br>//     return reg.test(str);<br>// }</p><h3 id="大写字母"><a href="#大写字母" class="headerlink" title="大写字母"></a>大写字母</h3><p>export function validateUpperCase(str) {<br>  const reg = /^[A-Z]+$/<br>  return reg.test(str)<br>}</p><h3 id="大小写字母"><a href="#大小写字母" class="headerlink" title="大小写字母"></a>大小写字母</h3><p>export function validatAlphabets(rule, str, callback) {<br>  const reg = /^[A-Za-z]+$/<br>  const regTest = reg.test(str)<br>  if (!regTest) {<br>    callback(new Error(‘大小写字母’))<br>  } else {<br>    callback()<br>  }<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex的使用总结</title>
      <link href="/2020/08/01/vuex%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/01/vuex%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>vuex是一个专门未vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>使用  npm install vuex –save<br>新建store文件夹/index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">import user from &#39;.&#x2F;modules&#x2F;user.js&#39;</span><br><span class="line"></span><br><span class="line">const store &#x3D; new Vuex.store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    modules:&#123;</span><br><span class="line">        user</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default store</span><br></pre></td></tr></table></figure><h3 id="在将store挂载到Vue的根组件上"><a href="#在将store挂载到Vue的根组件上" class="headerlink" title="在将store挂载到Vue的根组件上"></a>在将store挂载到Vue的根组件上</h3><p>main.js中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import store from &#39;.&#x2F;store&#39;</span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">&#x2F;* eslint-disable no-new *&#x2F;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">el: &#39;#app&#39;,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">template: &#39;&lt;App&#x2F;&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5个核心概念"><a href="#5个核心概念" class="headerlink" title="5个核心概念"></a>5个核心概念</h3><h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><pre><code>其仓库</code></pre><h4 id="mutation"><a href="#mutation" class="headerlink" title="mutation"></a>mutation</h4><pre><code>用于同步更新store中的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">    state.count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><pre><code>用于异步更新store中的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">    &#x2F;&#x2F; context.commit(&#39;increment&#39;)</span><br><span class="line">    setTimeout(function () &#123; context.commit(&#39;increment&#39;) &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><pre><code>相当于计算属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> getters: &#123;</span><br><span class="line">    doneTodos: state &#x3D;&gt; &#123;</span><br><span class="line">        return state.countNum + state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    user: state &#x3D;&gt; state.user.user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><pre><code>将store进行分块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import user from &#39;.&#x2F;modules&#x2F;user.js&#39;</span><br><span class="line">modules: &#123;</span><br><span class="line">    user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其中modules下的user.js这么写<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">    state: () &#x3D;&gt; (&#123; user: 3 &#125;),</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        changeUser (state) &#123;</span><br><span class="line">            state.user +&#x3D; 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        asyncChangeUser (context) &#123;</span><br><span class="line">            context.commit(&#39;changeUser&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        getUserAge: state &#x3D;&gt; state.user + &#39;岁&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default user</span><br></pre></td></tr></table></figure>访问时使用this.$store.state.user.user可以得到3使用this.$store.dispatch(&apos;asyncChnageUser&apos;)可以异步修改user模块中的user使用this.$store.commit(&apos;changeUser&apos;)可以同步修改user模块中的user使用this.getters.getUserAge 可以动态计算岁数</code></pre><h4 id="一次性引入所有modules"><a href="#一次性引入所有modules" class="headerlink" title="一次性引入所有modules"></a>一次性引入所有modules</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Vuex from &#39;vuex&#39;</span><br><span class="line">import getters from &#39;.&#x2F;getters.js&#39;</span><br><span class="line">&#x2F;&#x2F; import user from &#39;.&#x2F;modules&#x2F;user.js&#39;</span><br><span class="line">const modulesFiles &#x3D; require.context(&#39;.&#x2F;modules&#39;, true, &#x2F;\.js$&#x2F;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; you do not need &#96;import app from &#39;.&#x2F;modules&#x2F;app&#39;&#96;</span><br><span class="line">&#x2F;&#x2F; it will auto require all vuex module from modules file</span><br><span class="line">const modules &#x3D; modulesFiles.keys().reduce((modules, modulePath) &#x3D;&gt; &#123;</span><br><span class="line">&#x2F;&#x2F; set &#39;.&#x2F;app.js&#39; &#x3D;&gt; &#39;app&#39;</span><br><span class="line">const moduleName &#x3D; modulePath.replace(&#x2F;^\.\&#x2F;(.*)\.\w+$&#x2F;, &#39;$1&#39;)</span><br><span class="line">const value &#x3D; modulesFiles(modulePath)</span><br><span class="line">modules[moduleName] &#x3D; value.default</span><br><span class="line">return modules</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line">const state&#x3D; new Vue.store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters,</span><br><span class="line">    modules</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre><h4 id="module中开启命名空间"><a href="#module中开启命名空间" class="headerlink" title="module中开启命名空间"></a>module中开启命名空间</h4><p>在module中开启命名空间,加一个属性namespaced:true即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const user &#x3D; &#123;</span><br><span class="line">  namespaced: true, &#x2F;&#x2F;开启命名空间</span><br><span class="line">  state: () &#x3D;&gt; (&#123; user: 3 &#125;),</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeUser (state) &#123;</span><br><span class="line">      state.user +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    asyncChnageUser (context) &#123;</span><br><span class="line">      context.commit(&#39;changeUser&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getUserAge: state &#x3D;&gt; state.user + &#39;岁&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default user</span><br></pre></td></tr></table></figure><h5 id="进行action修改时"><a href="#进行action修改时" class="headerlink" title="进行action修改时"></a>进行action修改时</h5><p><code>this.$store.dispatch(&#39;user/asyncChnageUser&#39;)</code></p><h5 id="进行mutations修改时"><a href="#进行mutations修改时" class="headerlink" title="进行mutations修改时"></a>进行mutations修改时</h5><p><code>this.$store.dispath(&#39;user/changeUser&#39;)</code></p><h5 id="进行获取getters时"><a href="#进行获取getters时" class="headerlink" title="进行获取getters时"></a>进行获取getters时</h5><p><code>this.$store.getters[&#39;user/getUserAge&#39;]</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组降维方式</title>
      <link href="/2020/07/25/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/07/25/%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>数组字符串化<a id="more"></a>所有类型会转成字符串，且元素为对象类型会被转换成”[object Object]”,对于同一种类型数字或字符串还是可以的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [[1,2,3],[4,5,6],&#123;a:1&#125;]</span><br><span class="line">arr+&#x3D;&#39;&#39;</span><br><span class="line">arr &#x3D; arr.split(&#39;,&#39;)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;[object Object]&quot;]</span><br></pre></td></tr></table></figure></li><li>递归<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reduceDimension(arr)&#123;</span><br><span class="line">    let ret &#x3D; []</span><br><span class="line">    let toArr &#x3D; fuinction(arr)&#123;</span><br><span class="line">       arr.forEach(function(item)&#123;</span><br><span class="line">           item instanceof Array ? toArr(item) : ret.push(item)</span><br><span class="line">       &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">    toArr(arr)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Array.prototype.flat()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1,2,[3,4]]</span><br><span class="line">arr.flat() &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line"></span><br><span class="line">var arr2 &#x3D; [1,2,[3,4,[5,6]]]</span><br><span class="line">arr2.flat() &#x2F;&#x2F;[1,2,3,4,[5,6]]</span><br><span class="line"></span><br><span class="line">var arr3 &#x3D; [1,2,[3,4,[5,6]]]</span><br><span class="line">arr3.flat(2) &#x2F;&#x2F;[1,2,3,4,5,6]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用Infinity作为深度，展开任意层度的嵌套数组</span><br><span class="line">arr3.flat(Infinity) &#x2F;&#x2F;[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure></li><li>使用stack无限反嵌套多层嵌套数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1,2,3,[1,2,3,4,[2,3,4]]]</span><br><span class="line">function flatten(input)&#123;</span><br><span class="line">    const stack &#x3D; [...input]</span><br><span class="line">    const res &#x3D; []</span><br><span class="line">    while(stack.length)&#123;</span><br><span class="line">        &#x2F;&#x2F; 使用pop从stack中取出并移除值</span><br><span class="line">        const next &#x3D; stack.pop()</span><br><span class="line">        if(Array.isArray(next))&#123;</span><br><span class="line">            stack.push(...next)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res.push(next)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res.reverse()</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr1)</span><br></pre></td></tr></table></figure></li><li>使用reduce、concat和递归无限反嵌套多层嵌套的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D; [1,2,3,[2,3,4,[3,4,5,[4,5,6]]]]</span><br><span class="line">function flattenDeep(arr1)&#123;</span><br><span class="line">    return arr1.reduce((acc,val)&#x3D;&gt;Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), []);</span><br><span class="line">&#125;</span><br><span class="line">flattenDeep(arr1) &#x2F;&#x2F;  [1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6]</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES11</title>
      <link href="/2020/07/25/ES11/"/>
      <url>/2020/07/25/ES11/</url>
      
        <content type="html"><![CDATA[<ul><li>私有属性</li></ul><a id="more"></a><p>在ES11 中提供了私有变量，通过在变量或函数钱增加一个哈希符号#,即可设为私有属性，只能在类的内部使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    #age &#x3D; 0</span><br><span class="line">    constructor(age)&#123;</span><br><span class="line">        this.#age &#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">    getAge()&#123;</span><br><span class="line">        return this.#age</span><br><span class="line">    &#125;</span><br><span class="line">    setAge(age)&#123;</span><br><span class="line">        this.#age +&#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let zhangsan &#x3D; new Age(12)</span><br><span class="line">zhangsan.getAge() &#x2F;&#x2F; 12</span><br><span class="line">zhangsan.setAge(2) </span><br><span class="line">zhangsan.getAge() &#x2F;&#x2F; 14</span><br><span class="line">zhangsan.#age &#x3D; 18 &#x2F;&#x2F; Private field &#39;#age&#39; must be declared in an enclosing class</span><br><span class="line">console.log(zhangsan.#age) &#x2F;&#x2F; Private field &#39;#age&#39; must be declared in an enclosing class</span><br></pre></td></tr></table></figure><ul><li>空值合并运算符<br>取对象属性，如果这个属性没有值，会给默认值.<br>当左侧操作数为null或者undefined时，返回右侧的值，否则返回左侧的值。<br>?? 和 || 的区别:<br>|| 会首先对左侧的值进行boolean类型转换。当左侧值为” “或者是0时，会返回右侧的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let zhangsan &#x3D; &#123;</span><br><span class="line">    age: 12,</span><br><span class="line">    sex: 1,</span><br><span class="line">    hasHouse: 0</span><br><span class="line">&#125;</span><br><span class="line">console.log(zhangsan.age) &#x2F;&#x2F; 12</span><br><span class="line">console.log(zhangsan.sex) &#x2F;&#x2F; 1</span><br><span class="line">console.log(zhangsan.wife || &#39;未婚&#39;) &#x2F;&#x2F; 未婚</span><br><span class="line">console.log(zhangsan.hobby ?? &#39;打篮球&#39;) &#x2F;&#x2F; 打蓝球</span><br><span class="line">console.log(zhangsan.hasHouse || &#39;2&#39;) &#x2F;&#x2F; 2</span><br><span class="line">console.log(zhangsan.hasHouse ?? &#39;1&#39;) &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure></li><li>可选链操作符<br>减少访问深层次对象时判断属性存不存在的问题。<br>可选链中的?.表示问号左侧表达式有值，就回查询问号后面的字段。根据下面的结果可以看出，用可选链可以大量简化类似繁琐的前置校验操作，而且更安全。<br>?.不能用来赋值<br>通常可选链操作符与空值合并运算符一起使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a &#x3D; &#123;c:&#123;d:&#39;d&#39;&#125;&#125;</span><br><span class="line">console.log(a.b.c) &#x2F;&#x2F; 这里是Err，无法从undefined中得到c</span><br><span class="line">console.log(a?.c?.d) &#x2F;&#x2F; d</span><br><span class="line">console.log(a?.b?.c) &#x2F;&#x2F; undefined</span><br><span class="line">console.log(a?.b?.c ?? &#39;e&#39;) &#x2F;&#x2F; e</span><br></pre></td></tr></table></figure></li><li>动态引入<br>在项目中，某些功能可能很少使用，而导入所有依赖项可能只是浪费资源。现在可以使用async/await在需要时动态导入依赖项，可以在初始化的时候不全部加载逻辑资源，只进行按需加载这样可以让首屏的渲染速度更快，<br>demo.js导出模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const num &#x3D; (sum1,sum2)&#x3D;&gt;sum1+sum2</span><br></pre></td></tr></table></figure>html中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;module&quot;&gt;</span><br><span class="line">    const testAsync &#x3D; async(num1,num2)&#x3D;&gt;&#123;</span><br><span class="line">        let models &#x3D; await import(&#39;.&#x2F;demo.js&#39;)</span><br><span class="line">        console.log(models.num(num1,num2))</span><br><span class="line">    &#125;</span><br><span class="line">    testAsync(1,2)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>Access to script at ‘file:///C:/Users/Administrator/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/demo.js’ from origin ‘null’ has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.  需要在http环境进行</li></ul><ol><li>方法1：在VSCode中安装living server插件，将文件夹拖到工作区，点击living</li><li>npm i http-server -g 安装依赖，在目录执行http-server</li></ol><ul><li>globalThis<br>js在不同环境下的环境，获取全局对象是不一样的。NodeJs中通过global,Web中通过window,self等，有些甚至可以通过this。</li></ul><ul><li>全局变量window：是一个经典的获取全局对象的方法。但是它在Node.js和Web Workers中并不能使用。</li><li>全局变量self：通常只在Web Workers和浏览器中生效，但是它不支持Node.js</li><li>全局global：只在Nodel.js中生效<br>如果写一段js，可能在Node环境中运行，也可能在浏览器端，也可能在Web Workers环境中运行。这时候全局变量，必须使用一个方法去判断<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var getGlober &#x3D; function()&#123;</span><br><span class="line">    if(typeof self !&#x3D;&#x3D; &#39;undefined&#39;)&#123;return self&#125;</span><br><span class="line">    if(typeof window !&#x3D;&#x3D; &#39;undefined&#39;)&#123;return window&#125;</span><br><span class="line">    if(typeof globel !&#x3D;&#x3D; &#39;undefined&#39;)&#123;return global&#125;</span><br><span class="line">    thrownewError(&#39;unable to locate global object&#39;)</span><br><span class="line">&#125;</span><br><span class="line">var globals &#x3D; getGlober()</span><br></pre></td></tr></table></figure>ES11 中提供了globalThis，提供了标准化方式访问全局对象，有了globalThis后，可以在任意上下文，任意时刻获取到全局对象。<br>globalThis提供了一个标准的方式来获取不同环境下的全局this对象，所以不用担心运行环境。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; worker.js</span><br><span class="line">console.log(globelThis &#x3D;&#x3D;&#x3D; this) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; node.js</span><br><span class="line">console.log(globelThis &#x3D;&#x3D;&#x3D; this) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 浏览器</span><br><span class="line">console.log(globelThis &#x3D;&#x3D;&#x3D; window) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Promise.all缺陷<br>Promise.all具有并发执行异步任务的功能。最大的问题是如果某个任务出现异常(reject)，所有任务都会挂掉，Promise直接进入reject状态。<br>如果一个页面有3个区域，分别对应3个独立的接口数据，使用Promise.all来并发三个接口，如果其中一个接口服务异常，状态是reject，这会导致页面中3个区域的数据都无法渲染，因为reject都会进入catch回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let a&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  resolve(&#123; code: 200,msg:&quot;请求成功&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let b&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  resolve(&#123; code: 200,msg:&quot;请求成功&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let c&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  reject(&#123; code: 500,msg:&quot;服务器出现异常&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;使用Promise.all 进行并发执行异步任务</span><br><span class="line">Promise.all([a,b,c])</span><br><span class="line">.then((res) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 只有 上面所有的请求都是 resolve (成功) 的时候才会进入此回调中</span><br><span class="line">    console.log(res,&quot;res&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">.catch((error) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 上面的请求中，只要有一个是reject (失败) 就会进入此回调</span><br><span class="line">    console.log(error,&quot;error&quot;)</span><br><span class="line">    &#x2F;&#x2F; error: &#123;code: 500, msg: &quot;服务异常&quot;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Promise.allSettled<br>当我们处理多个Promise时，尤其是他们互相依赖时，记录每个事件在调试中发生的错误可能很有用。使用Promise.allSettled，他会创建一个新的Promise，在所有Promise完成后返回一个promise结果的数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let a&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  resolve(&#123; code: 200,msg:&quot;请求成功&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let b&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  resolve(&#123; code: 200,msg:&quot;请求成功&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">let c&#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">  &#x2F;&#x2F;异步操作...</span><br><span class="line">  reject(&#123; code: 500,msg:&quot;服务器出现异常&quot;&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;使用进行并发请求</span><br><span class="line">Promise.allSettled([a,b,c]).then((data&#x3D;&gt;&#123;</span><br><span class="line">  console.log(data,&quot;data&quot;)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回的数据中 ，status: &quot;fulfilled&quot; 表示请求成功，status: &quot;rejected&quot; 表示请求失败</span><br></pre></td></tr></table></figure></li><li><p>Promise.allSettled的优势<br>Promise.allSettled跟Promise.all类似，都是并发进行，他们的区别在于Promise.all进行并发请求的时候，只要有一个请求出现问题（异常），所有的请求正常也不能拿到数据，但是在我们的业务的开发中，我们需要保障我们业务的最大的可访问性，就是在我们执行并发任务中，不管我这个并发任务中的任何一个任务是正常还是异常，我们都需要拿到返回的对应的状态，在ES11中Promise.allSettled就为我们解决了这个问题，他和Promise.all类似，参数接收一个Promise的数组，返回一个新的Promise，也就是说当Promise全部处理完成后，我们可以拿到每个Promise的状态，而不管是否处理成功。我们可以在then里边通过filter来过滤想要的业务逻辑结果，这样就解决了Promise.all的缺陷。</p></li><li><p>BigInt 任意精度整数</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript中的LHS和RHS查询</title>
      <link href="/2020/07/25/javaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%E6%9F%A5%E8%AF%A2/"/>
      <url>/2020/07/25/javaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>LHS查询：赋值操作左侧的查询，LHS查询视图找到变量的容器本身，从而对其赋值<br>RHS查询：赋值操作右侧的查询，可以理解为”取到某某的值”</p><a id="more"></a><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">    var b &#x3D; a;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">var c &#x3D; foo(2)</span><br></pre></td></tr></table></figure><p>以上代码有3个LHS与4个RHS</p><ol><li>var c中的c需要被复制，在赋值操作符的左侧，对c进行了LHS引用</li><li>变量c需要被赋值，他的值是foo(2)，那么foo(2)的值多少呢，需要查找foo(2)的值，在赋值操作的右侧，所以对foo(2)进行RHS引用</li><li>隐含赋值操作，将2传递给function foo(a) {}函数的参数a，a在赋值操作的左侧，对a进行了LHS引用</li><li>var b = a，b需要被赋值，处在赋值操作的左侧，所以b进行了LHS，b的值将从a来，那么右侧的a的值从何而来呢，这就需要赋值操作右侧的a进行RHS。</li><li>return a+b 需要找到a与b的值来源，a与b都在赋值操作的右侧，才能得到a+b的制作，所以对a与b都是RHS引用</li></ol><p>为什么要区分LHS与RHS？<br>因为在变量还没有声明（在任何作用域中都无法找到该变量）情况下，这两种查询行为是不一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a)&#123;</span><br><span class="line">    console.log(a+b)</span><br><span class="line">    b&#x3D;a;</span><br><span class="line">&#125;</span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure><p>以上代码对b进行RHS的时候无法找到该变量的值，则会抛出ReferenxeError异常，如果是LHS找不到变量，非严格模式下，会在全局作用域中，创建一个具有该名称的变量，严格模式下，会跑出与RHS类似的异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function init(a)&#123;</span><br><span class="line">    b &#x3D; a + 3</span><br><span class="line">&#125;</span><br><span class="line">init(2)</span><br><span class="line">alert(b)</span><br></pre></td></tr></table></figure><p>以上代码，对b进行LHS没有找到变量，在全局作用域中创建了一个同名的变量b，在函数init外部可以访问到b变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function init()&#123;</span><br><span class="line">    var b &#x3D; a + 3</span><br><span class="line">&#125;</span><br><span class="line">init(2)</span><br><span class="line">alert(b)</span><br></pre></td></tr></table></figure><p>在function中定义了一个局部变量b，全局作用域中定义，控制台报错。<br>Uncaught ReferenceError：b is not defined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function init(a)&#123;</span><br><span class="line">    var b&#x3D;a+3</span><br><span class="line">&#125;</span><br><span class="line">init(2)</span><br><span class="line">alert(window.b)</span><br></pre></td></tr></table></figure><p>将代码改成如下所示，控制台没有报错，因为window.b作为weindow的一个属性访问，所以会返回undefined，而b作为 一个变量没有定义的时候是会报错的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>节抖和防流</title>
      <link href="/2020/07/25/%E8%8A%82%E6%8A%96%E5%92%8C%E9%98%B2%E6%B5%81/"/>
      <url>/2020/07/25/%E8%8A%82%E6%8A%96%E5%92%8C%E9%98%B2%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>节抖和防流的源码实现</p><a id="more"></a><table><thead><tr><th></th><th>防抖</th><th>节流</th></tr></thead><tbody><tr><td>概念</td><td>一段时间内频繁触发同一件事件，只会最后之星一次事件函数</td><td>在规定的时间内，无论触发多频繁，会且只会执行一次事件函数</td></tr><tr><td>实现原理（延时处理）</td><td>设置一个计时器，约定在XX毫秒后再触发事件处理，每次触发事件都会重置计时器，直到x毫秒内无2次操作</td><td>设置一个定时器，约定XX毫秒后执行事件，如果时间到了，就执行函数，并重置定时器</td></tr><tr><td>应用场景</td><td>搜索框/滚动条的监听事件处理等。如果不做防抖，没输入一个字/滚动屏幕，都会触发事件处理，造成性能浪费</td><td>窗口调整，页面滚动，请购疯狂点击等。防止用户去疯狂点击甚至是使用恶意脚本去实现疯狂点击按钮</td></tr><tr><td>区别</td><td>都可以极大的优化网络请求性能，提高用户体验。防抖是延迟执行，而节流是间隔执行。防抖每次触发事件都要重置计时器，而节流在计时器到时间后再清空计时器</td><td></td></tr><tr><td>缺点</td><td>每次清除定时器后重新计时，则延时时间变得更长</td><td>短时间内无法联系调用事件函数，只有等上一次触发规定延时过后才能调用</td></tr></tbody></table><p>防抖函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, delay) &#123; &#x2F;&#x2F; fn 回调函数 delay 延迟时间</span><br><span class="line">    let timer &#x3D; null</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; areuments</span><br><span class="line">        if(timer) &#123;</span><br><span class="line">            clearTimrout(time)</span><br><span class="line">        &#125;</span><br><span class="line">        timer &#x3D; setTimeout( () &#x3D;&gt; &#123;</span><br><span class="line">            fn.apply(context,args)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节流函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function thrttlr(fn, wait)&#123;</span><br><span class="line">    let timer &#x3D; null</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; arguments</span><br><span class="line">        if(!timer) &#123;</span><br><span class="line">            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                timer &#x3D; null</span><br><span class="line">                fn.apply(context, args)</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用两个时间戳lasttime旧时间戳和nowtime新时间戳，每次触发事件都判断二者的时间差，如果到达规定时间，执行函数并重置旧时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fn, wait)&#123;</span><br><span class="line">    var lasttime &#x3D; 0;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let nowtime &#x3D; Date.now()</span><br><span class="line">        let context &#x3D; this</span><br><span class="line">        let args &#x3D; arguments</span><br><span class="line">        if(nowtime - lasttime &gt; wait)&#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">            lasttime &#x3D; nowtime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6Promise</title>
      <link href="/2020/07/25/ES6Promise/"/>
      <url>/2020/07/25/ES6Promise/</url>
      
        <content type="html"><![CDATA[ <!-- [ES6 Promise](https://www.cnblogs.com/lvdabao/p/es6-promise-1.html#!comments) --><p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样眼熟的方法。用Promise new出来的对象也是同样有then、catch方法的。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行成功&#39;)</span><br><span class="line">        resolve(&#39;随便什么数据&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>Promise的构造函数接收一个参数，是函数，并且传入两个参数resolve，reject，分别表示一步操作执行成功后的回调函数和异步操作失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来说，reslove是将Promise的状态设置为fullfiled，reject是将Promise的状态设置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p><p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并调用resolve()方法、</p><p>运行程序，会在2秒后输出“执行完成”。注意！我只是new了一个对象。并没有调用它，我们传进去的韩束就已经执行，这需要注意的细节。所以我们用Promise的时候一般时包在一个函数中，在需要的时候去运行这个函数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function runAsync()&#123;</span><br><span class="line">    var p&#x3D; new Promise(function(resolve,reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&quot;执行完成&quot;)</span><br><span class="line">            resolve(&quot;随便什么数据&quot;)</span><br><span class="line">        &#125;,1000)</span><br><span class="line">    &#125;)</span><br><span class="line">    return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runAsync()</span><br></pre></td></tr></table></figure><p>那么问题来了，我们为什么要包装一个函数？这个resolve(“随便什么数据”)；这是干什么用的</p><p>在我们包装好的函数最后，会return出Promise，也就是说，执行这个函数我们得到了一个Promise对象，还记得Promise对象上有then、catch方法吧？这是强大之处，看下面代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">runAsync().then(function()&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">    &#x2F;&#x2F; 可用于进行处理其他操作</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的参数。运行这段代码，会在2s后输出“执行完成”，紧接着输出“随便什么数据”</p><p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行后，用链式调用的方法执行回调函数。</p><p>那我将回调函数封装一下不是一样吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function runAsync(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&#39;执行完成&#39;)</span><br><span class="line">        callback(&#39;随便什么数据&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;</span><br><span class="line">runAsync(function(data)&#123;</span><br><span class="line">    conole.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完也需要有相应的回调函数，该怎么办呢？总不能在定义一个callback2，然后给callback传进去吧。而Promise的优势在于可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><p>链式操作的用法</p><p>所以，从表面上看，Promise只能够简化蹭蹭回调的写法，而实质上，Promise的精髓是“状态”，用维护状态。传递状态的方式来使得回调函数能够即时调用，它比传递callback函数要简单、灵活的多。所以用Promise的正确场景是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">runAsync1()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">    return runAsync2()</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">    return runAsync3()</span><br><span class="line">&#125;)</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样能够按顺序，每隔2秒输出每隔异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function runAsync1()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务1执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据1&#39;);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">function runAsync2()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务2执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据2&#39;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">function runAsync3()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务3执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据3&#39;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在then方法中，你可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们吧上面的代码修改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function runAsync1()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务1执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据1&#39;);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">function runAsync2()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务2执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据2&#39;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">function runAsync3()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&#39;异步任务3执行完成&#39;);</span><br><span class="line">            resolve(&#39;随便什么数据3&#39;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reject的用法<br>到这里，对‘Promise是什么玩意’有了基本的了解。那么我们看看还有什么其他功能。我们光用了了resolve，还没有用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中能补助到，然后执行“失败”情况的回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function getNumber()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        &#x2F;&#x2F;做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var num &#x3D; Math.ceil(Math.random()*10); &#x2F;&#x2F;生成1-10的随机数</span><br><span class="line">            if(num&lt;&#x3D;5)&#123;</span><br><span class="line">                resolve(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                reject(&#39;数字太大了&#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">getNumber()</span><br><span class="line">.then(</span><br><span class="line">    function(data)&#123;</span><br><span class="line">        console.log(&#39;resolved&#39;);</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(reason, data)&#123;</span><br><span class="line">        console.log(&#39;rejected&#39;);</span><br><span class="line">        console.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是”成功”了，调用resolve修改Promise的状态，否则我们认为是失败了，调用reject并传递一个参数，作为失败的原因。</p><p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，会得到两种结果。</p><p>catch的用法</p><p>我们知道Promise对象除了then方法，haiyoucatch方法，他是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&#39;resolved&#39;);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&#39;rejected&#39;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样和写then的第二个参数里面一样，不过他还有另外一个作用，在执行resolve的回调（也就是上面then的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&#39;resolved&#39;);</span><br><span class="line">    console.log(data);</span><br><span class="line">    console.log(somedata); &#x2F;&#x2F;此处的somedata未定义</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&#39;rejected&#39;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(sonedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码执行到这里直接在控制台报错了，不往下运行了。但是在控制台会得到一些提示</p><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即使是有错误的代码也不会报错，这与我们的try/catch语句有相同功能。</p><p>all的用法<br>Promise的all方法提供了并行执行异步操作的能力，并且在 所有异步操作执行完成后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.all([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用Promise.all来执行，all接收一个数组参数，里面的值最终都返回Promise对象。这样，三个异步操作的并行执行的，等到它们执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。</p><p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？在一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载用到的各种资源，如图片，falsh以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p><p>race的用法<br>all方法的效果实际上是[谁跑得慢，以谁为准执行回调]，那么相对的就有另外一个方法[谁跑得快，就以谁为准执行回调]，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们吧上面runAsync1的延迟改为1秒来看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.race([runAsync1(), runAsync2(), runAsync3()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这三个异步操作同样是并行执行的。结果应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了</p><p>在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧在执行。于是再过1秒，输出他们执行结束的标志。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;请求某个图片资源</span><br><span class="line">    function requestImg()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        var img &#x3D; new Image();</span><br><span class="line">        img.onload &#x3D; function()&#123;</span><br><span class="line">            resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        img.src &#x3D; &#39;xxxxxx&#39;;</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;延时函数，用于给请求计时</span><br><span class="line">function timeout()&#123;</span><br><span class="line">    var p &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            reject(&#39;图片请求超时&#39;);</span><br><span class="line">        &#125;, 5000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise</span><br><span class="line">.race([requestImg(), timeout()])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>requestImg函数会异步请求一张鱼片，将地址写为“XXXXX”所以肯定是无法请求到的，timeout函数是一个延迟5秒的异步操作，我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么便进入then方法，执行正常流程。如果5秒图片还未成功返回，那么timeout就跑赢了，则进入catch，报错“图片请求超时”的信息</p><p>总结：<br>ES6 Promise的内容就这些吗？是的，能用到的基本就这些。<br>我怎么还见过done、finally、success、file等，这些是啥？这些并不在Promise标准中，而是我们自己实现的语法糖。</p><p>本文中所有异步操作均已setTImeout为例子，之所以不使用ajax是为了避免引起混淆，因为谈起ajax，很多人的第一反应就是jquery的ajax，而jquery又有自己的Promise实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解js创建对象</title>
      <link href="/2020/07/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/07/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ol><li>Object构造函数</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; new Object()</span><br><span class="line">person.name &#x3D; &#39;张三&#39;</span><br></pre></td></tr></table></figure><p>缺点：使用同一个接口创建很多对象，会产生大量的重复代码</p><ol start="2"><li>对象字面量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123; name:&#39;zhangsan&#39; &#125;</span><br></pre></td></tr></table></figure><p>缺点：同Object构造函数。使用用一个接口创建很多对象，会产生大量的重复代码</p><ol start="3"><li>Object.create方式</li></ol><p>Object.create()方法会使用指定的原型对象及其属性去创建一个新的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Person &#x3D; &#123;</span><br><span class="line">    name :&#39;zhangsan&#39;</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; Object.create(Person)</span><br><span class="line">var person2 &#x3D; Object.create(Person)</span><br><span class="line">person1.sayName() &#x2F;&#x2F; &#39;zhangsan&#39;</span><br><span class="line">person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>优点：单例继承，语法简单。<br>缺点：封装性不好，多实例需要重复初始化过程。</p><ol start="4"><li>工厂模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name)&#123;</span><br><span class="line">    var o &#x3D; new Object()</span><br><span class="line">    o.name &#x3D; name</span><br><span class="line">    o.sayName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">    return o</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; createPerson(&#39;张三&#39;)</span><br><span class="line">var person2 &#x3D; createPerson(&#39;李四&#39;)</span><br></pre></td></tr></table></figure><p>优点：实现函数封装，无数次调用，都返回一个对象。<br>缺点：无法识别对象，因为所有实例的constructor都指向Object。</p><ol start="5"><li>构造函数模式</li></ol><p>构造函数模式：通过new关键字方式调用。<br>在构造函数内部，也就是被调用的函数内 this指向新创建的对象Object。这个新创建的对象的prototype被指向到构造函数的prototype。<br>如果被调用的函数没有显示的return表达式，则隐式的会返回this对象，也就是新创建的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.sayName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person(&#39;张三&#39;)</span><br><span class="line">var person2 &#x3D; new Person(&#39;李四&#39;)</span><br><span class="line">person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>优点：通过constructor或者instanceof可以识别对象实例的类别。<br>缺点：浪费内存。每个方法都要在每个实例上重新创建一遍。</p><ul><li>原型模式</li></ul><p>原型（prototype）：每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。原型对象（Person.prototype）是构造函数（Person）的一个实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">Person.prototype.name &#x3D; &#39;张三&#39;</span><br><span class="line">Person.prototype.sayName &#x3D; function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person()</span><br><span class="line">person1.sayName() &#x2F;&#x2F; 张三</span><br><span class="line"></span><br><span class="line">var Person2 &#x3D; new Person()</span><br><span class="line">person2.sayName() &#x2F;&#x2F; 张三</span><br><span class="line"></span><br><span class="line">person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>通过prototype添加的属性和放大所有实例共享。</li><li>可以动态的添加原型对象的属性和方法，并直接反映到实例上<br>缺点：</li><li>实例无法重写原型中的值</li><li>访问实例的某个属性时，会先搜索对象实例本身，如果对象实例中具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，如果在原型对象中找到该属性，则返回该属性的值。</li></ul><ul><li>构造函数和原型的组合模式</li></ul><p>构造函数模式用于定义实例模式，而原型模式用于定于方法和共享的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.friends &#x3D; [&#39;张三&#39;, &#39;李四&#39;]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">    constructor: Person, &#x2F;&#x2F; 手动将constructor指向Person，否则constuctor将指向Object</span><br><span class="line">    sayName: function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 &#x3D; new Person(&quot;one&quot;)</span><br><span class="line">var person2 &#x3D; new Person(&quot;two&quot;)</span><br><span class="line"></span><br><span class="line">person1.friends.push(&quot;王五&quot;)</span><br><span class="line"></span><br><span class="line">person1.friends &#x2F;&#x2F; [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span><br><span class="line">person2.friends &#x2F;&#x2F; [&quot;张三&quot;, &quot;李四&quot;]</span><br><span class="line">person1.friends &#x3D;&#x3D;&#x3D; person2.friends &#x2F;&#x2F; false</span><br><span class="line">person1.sayName &#x3D;&#x3D;&#x3D; person2.sayName &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>优点：是使用最广泛、认同度最高的一种创建自定义类型的方法。</p><ul><li>每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法引用，最大限度地节省了内存；</li><li>支持向构造函数传递参数。</li></ul><p>缺点：缺乏更好的封装性</p><ul><li>动态原型模式</li></ul><p>动态原型密匙将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    if (typeof this.sayName !&#x3D;&#x3D; &quot;function&quot;)&#123;</span><br><span class="line">        Person.prototype.sayName &#x3D; function() &#123;</span><br><span class="line">            console.log(this.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person(&quot;a&quot;)</span><br><span class="line">person.sayName()</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>仅在需要的时候初始化原型，节省内存；</li><li>对原型所做的修改，都能立即在所有实例中得到反映。<br>缺点： —–<br>注意：使用动态原型模式时，不能使用对象字面量重写原型。因为，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的关系。</li></ul><ul><li>寄生构造模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    var o &#x3D; new Object()</span><br><span class="line">    o.name &#x3D; name</span><br><span class="line">    o.sayName &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">    return o</span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person(&quot;a&quot;)</span><br><span class="line">person.sayName() &#x2F;&#x2F; a</span><br></pre></td></tr></table></figure><p>优点：在上面的几种模式都不适用的时候，可以使用该方法。比如：创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，可以使用这个模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function SpecialArray() &#123;</span><br><span class="line">    var Array &#x3D; new Array()</span><br><span class="line">    arr.push.apply(array,arguments)</span><br><span class="line">    arr.toPipedString &#x3D; function()&#123;</span><br><span class="line">        return this.join(&quot;|&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return array</span><br><span class="line">&#125;</span><br><span class="line">colors &#x3D; new SpecialArray(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)</span><br><span class="line">colors.toPipedString() &#x2F;&#x2F; &quot;red|blue|green&quot;</span><br></pre></td></tr></table></figure><p>缺点：无法使用instanceof来识别对象所属类型</p><ul><li>稳妥构造函数模式<br>稳妥对象：</li></ul><ul><li>没有公共属性，而且其方法也不引用this的对象</li><li>最合适在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序改动时使用。</li></ul><p>稳妥构造函数和寄生构造函数的区别：</p><ul><li>新创建对象的实例方法不引用this</li><li>不适用new操作符调用构造函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    var o&#x3D; new Object()</span><br><span class="line">    o.sayName &#x3D; function() &#123;</span><br><span class="line">        console.log(name)</span><br><span class="line">    &#125;</span><br><span class="line">    retur o </span><br><span class="line">&#125;</span><br><span class="line">var person &#x3D; new Person();</span><br><span class="line">person.sayName()</span><br></pre></td></tr></table></figure>优点：非常适合在某些安全执行环境下使用<br>缺点：无法使用instance来识别对象所属类型</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>morgan中间件记录日志</title>
      <link href="/2020/07/25/morgan%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/"/>
      <url>/2020/07/25/morgan%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>第一次使用node写接口，本以为只是简单的增删改查，将基本的增删改查之后，随着对后端的裂解，故想增加了记录日志。日志对于服务器的日常维护与问题回顾起着很大的作用，故自己完善这部分功能。</p><a id="more"></a><p>Express 框架使用 morgan 中间件记录日志，而且在 app.js 文件中已经默认引入了该中间件 var logger = require(‘morgan’);<br>使用 app.use(logger(‘dev’)); 可以将请求信息打印在控制台，便于开发调试，但实际生产环境中，通常需要将日志记录在日志文件里，<a href="https://www.npmjs.com/package/morgan" target="_blank" rel="noopener">morgan</a>的官方文档说明的非常详细。<a href="https://www.php.cn/js-tutorial-393516.html" target="_blank" rel="noopener">morgan</a>中文详解。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">var logger &#x3D; require(&#39;morgan&#39;);</span><br><span class="line"></span><br><span class="line">var app &#x3D; express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create a write stream (in append mode) </span><br><span class="line">var accessLogStream &#x3D; fs.createWriteStream(__dirname + &#39;&#x2F;access.log&#39;, &#123;flags: &#39;a&#39;&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setup the logger </span><br><span class="line">app.use(logger(&#39;combined&#39;, &#123;stream: accessLogStream&#125;));</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">    res.send(&#39;hello, world!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><p>将日志按日期进行生成单个文件<br>安装file-stream-rotator<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var FileStreamRotator &#x3D; require(&#39;file-stream-rotator&#39;);</span><br><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">var logger &#x3D; require(&#39;morgan&#39;);</span><br><span class="line"></span><br><span class="line">var app &#x3D; express();</span><br><span class="line">var logDirectory &#x3D; __dirname + &#39;&#x2F;log&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ensure log directory exists </span><br><span class="line">fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create a rotating write stream </span><br><span class="line">var accessLogStream &#x3D; FileStreamRotator.getStream(&#123;</span><br><span class="line">    date_format: &#39;YYYYMMDD&#39;,</span><br><span class="line">    filename: logDirectory + &#39;&#x2F;%DATE%.log&#39;,</span><br><span class="line">    frequency: &#39;daily&#39;,</span><br><span class="line">    verbose: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; setup the logger </span><br><span class="line">app.use(logger(&#39;combined&#39;, &#123;stream: accessLogStream&#125;));</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function (req, res) &#123;</span><br><span class="line">    res.send(&#39;hello, world!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Sequelize </tag>
            
            <tag> Express </tag>
            
            <tag> morgan </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见代码手写部分</title>
      <link href="/2020/07/25/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/"/>
      <url>/2020/07/25/%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E6%89%8B%E5%86%99%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<ul><li>通用的事件侦听器函数</li></ul><a id="more"></a><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">const EventUtils &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加事件</span><br><span class="line">    addEvent: function(element, type, handler)&#123;</span><br><span class="line">        if(element.addEventListener) &#123;</span><br><span class="line">            element.addEventListener(type, handler, false)</span><br><span class="line">        &#125;else if(element.atachEvent) &#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot;+type, handler)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            element[&quot;on&quot;+type] &#x3D; handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 移除事件</span><br><span class="line">    romoveEvent: function(element, type, handler)&#123;</span><br><span class="line">        if(element.removeEventListener) &#123;</span><br><span class="line">            element.removeEventListener(type, handler, false)</span><br><span class="line">        &#125;else if(element.detachEvent) &#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot;+type,handler)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            element[&quot;on&quot;+type] &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取事件目标</span><br><span class="line">    getTarget: function(event) &#123;</span><br><span class="line">        return event.target || event.srcElement</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取event对象的引用，取到时间的所有所有信息，确保随时能使用event</span><br><span class="line">    getEvent: function(event)&#123;</span><br><span class="line">        return event || window.event</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻止事件（主要是事件冒泡，因为IE不支持时间捕获）</span><br><span class="line">    stopPropagation: function(event) &#123;</span><br><span class="line">        if(event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            event.cancelBubble &#x3D; true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 取消事件的默认行为</span><br><span class="line">    preventDefault: function(event) &#123;</span><br><span class="line">        if(event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            event.returnValue &#x3D; false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>高阶函数<br>高阶函数只是将函数作为参数或返回值的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function higerOrderFunction(param, callback)&#123;</span><br><span class="line">    return callback(params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动实现<code>Array.prototype.map</code>方法<br>map()方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function map(arr,mapCallback)&#123;</span><br><span class="line">    if(!Array.isArray(arr) || !arr.length || typeof mapCallback !&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        let result &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 每次调用此函数创建一个result数组。</span><br><span class="line">        &#x2F;&#x2F; 因为我们不想改变原始数组。</span><br><span class="line">        for(let i&#x3D;0; len&#x3D;arr.length; i &lt; len; i++)&#123;</span><br><span class="line">            result.push(mapCallback(arr[i], i, arr))</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动实现<code>Array.prototype.filter</code>方法<br>filter方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function filter(arr, filterCallback)&#123;</span><br><span class="line">    if(!Array.isArray(arr) || !arr.length || typeof filterCallback !&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        let result &#x3D; [];</span><br><span class="line">        for (let i&#x3D; 0;len&#x3D;result.length; i&lt; len; i++)&#123;</span><br><span class="line">            if(filterCallback(arr[i],i,arr))&#123;</span><br><span class="line">                result.push(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动实现<code>Array.prototype.reduce</code>方法<br><a href="">reduce()</a>方法对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function reduce(arr, reduceCallBack, initialValue) &#123;</span><br><span class="line">    if(!Array.isArray(arr) || !arr.length || reduceCallBack !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let hasInitialValue &#x3D; initialValue !&#x3D;&#x3D; undefined</span><br><span class="line">        let value &#x3D; hasInitialValue ? initialValue : arr[0]</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果有传递initialValue,则索引从1开始，否则从0开始</span><br><span class="line">        for (let i &#x3D; hasInitialValue ? 0 : 1,len&#x3D;arr.lrngth; i &lt; len; i++ )&#123;</span><br><span class="line">            value &#x3D; reduceCallback(value, arr[i], i, arr)</span><br><span class="line">        &#125;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6新特性</title>
      <link href="/2020/07/25/ES6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/07/25/ES6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<ul><li>ES6新特性</li></ul><a id="more"></a><ul><li>块作用域</li><li>类</li><li>箭头函数</li><li>模板字符串</li><li>加强的对象字面</li><li>对象结构</li><li>Promise</li><li>模块</li><li>Symbol</li><li>代理（proxy）</li><li>Set</li><li>函数默认参数</li><li>rest和展开</li></ul><ul><li><p>‘var’，‘let’和‘const’的区别<br>var 声明的变量会挂载在window上。而let和const声明不会：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 100</span><br><span class="line">console.log(a, window.a) &#x2F;&#x2F; 100, 10</span><br><span class="line">let b &#x3D; 10;</span><br><span class="line">console.log(b, window.b) &#x2F;&#x2F; 10 undefined</span><br><span class="line">let c &#x3D; 1;</span><br><span class="line">console.log(c, window.c) &#x2F;&#x2F; 1 undefined</span><br></pre></td></tr></table></figure><p>var 声明的变量存在变量提升，let和const 不存在变量提升：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; undefiner &#x3D;&#x3D;&#x3D;&gt; a已经声明但还没赋值，默认得到undefined</span><br><span class="line">var a &#x3D; 100</span><br><span class="line"></span><br><span class="line">console.log(b) &#x2F;&#x2F; 报错：b is not defined &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br><span class="line">let b &#x3D; 10</span><br><span class="line"></span><br><span class="line">console.log(c) &#x2F;&#x2F; 报错：c is not defined &#x3D;&#x3D;&#x3D;&gt;找不到c这个变量、</span><br><span class="line">const c &#x3D; 1</span><br></pre></td></tr></table></figure><p>let 和 const 声明形成块作用域</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    if(true)&#123;</span><br><span class="line">        var a &#x3D; 100</span><br><span class="line">        let b &#x3D; 10</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a) &#x2F;&#x2F; 100</span><br><span class="line">    console.log(b) &#x2F;&#x2F; 报错：b is not defined &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br><span class="line">------------------------------------</span><br><span class="line">  if(true)&#123;</span><br><span class="line">        var a &#x3D; 100</span><br><span class="line">        const c &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(a) &#x2F;&#x2F; 100</span><br><span class="line">    console.log(c) &#x2F;&#x2F; 报错：c is not defined &#x3D;&#x3D;&#x3D;&gt; 找不到b这个变量</span><br></pre></td></tr></table></figure><p>同一个作用域下let和const 不能声明同名变量 而var可以</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 100</span><br><span class="line">console.log(a) &#x2F;&#x2F; 100</span><br><span class="line">var a &#x3D; 10</span><br><span class="line">console.log(a) &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">let b &#x3D; 100</span><br><span class="line">let b &#x3D; 100</span><br><span class="line"></span><br><span class="line">报错 Identifier &#39;b&#39; has already been declared  &#x3D;&#x3D;&#x3D;&gt; 标识符b已经被声明了。</span><br></pre></td></tr></table></figure><p>暂时性死区</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 100;</span><br><span class="line">if(true) &#123;</span><br><span class="line">    a &#x3D; 10;</span><br><span class="line">    &#x2F;&#x2F; 在当前块作用域中声明a使用let&#x2F;const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class="line">    &#x2F;&#x2F; 而这时，还未到声明时候，所以控制台 Error：a is not defined </span><br><span class="line">    let a &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*   1. 一旦声明，必须赋值，不能使用null占位</span><br><span class="line">*   2. 声明后不能修改</span><br><span class="line">*   3. 如果生命的是复合类型数据，可以修改其属性</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><ul><li><p>箭头函数<br>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguemnts，suprt或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var getCurrentDate &#x3D; function ()&#123;</span><br><span class="line">    return new Date()</span><br><span class="line">&#125;</span><br><span class="line">const getCurrentDate &#x3D; () &#x3D;&gt; new Date()</span><br></pre></td></tr></table></figure><p>在本例中，ES5版本有function() {}声明和return关键字，这两个关键字分别是创建函数和返回值做需要的。在箭头函数版本中，我们只需要()括号，不需要return语句，因为如果我们只有一个表达式或值需要返回，箭头函数就会有隐式的返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES5 Version</span><br><span class="line">function greet(name) &#123;</span><br><span class="line">return &#39;Hello &#39; + name + &#39;!&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES6 Version</span><br><span class="line">const greet &#x3D; (name) &#x3D;&gt; &#96;Hello $&#123;name&#125;&#96;;</span><br><span class="line">const greet2 &#x3D; name &#x3D;&gt; &#96;Hello $&#123;name&#125;&#96;;</span><br></pre></td></tr></table></figure><p>我们还可以在箭头函数中使用与函数表达式和函数声明相同的参数。如果我们在一个箭头函数中有一个参数，则可以省略括号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const getArgs &#x3D; () &#x3D;&gt; arguments</span><br><span class="line">const getArgs2 &#x3D; (...rest) &#x3D;&gt; rest</span><br></pre></td></tr></table></figure><p>箭头函数不能访问arguments对象。所以调用第一个getArgs函数会跑出一个错误。相反，我们使用rest参数来获得在箭头函数中传递的所有参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const data &#x3D; &#123;</span><br><span class="line">    result: 0,</span><br><span class="line">    nums: [1, 2, 3, 4, 5],</span><br><span class="line">    computeResult() &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里的“this”指的是“data”对象</span><br><span class="line">        const addAll &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        return this.nums.reduce((total, cur) &#x3D;&gt; total + cur, 0)</span><br><span class="line">        &#125;;</span><br><span class="line">        this.result &#x3D; addAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult 方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。</p></li><li><p>什么是类<br>类（class）是在JS中编写构造函数的新方法。它是使用构造函数的语法糖，在底层中仍然是原型和基于原型的继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Person(firstName, lastName, age, address)&#123;</span><br><span class="line">    this.firstName &#x3D; firstName</span><br><span class="line">    this.lastName &#x3D; lastName</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">    this.address &#x3D; address</span><br><span class="line">&#125;</span><br><span class="line">Person.self &#x3D; function()&#123;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"> Person.prototype.toString &#x3D; function()&#123;</span><br><span class="line">    return &quot;[object Person]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getFullName &#x3D; function ()&#123;</span><br><span class="line">    return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 </span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(firstName, lastName, age, address)&#123;</span><br><span class="line">        this.firstName &#x3D; firstName</span><br><span class="line">        this.lastName &#x3D; lastName</span><br><span class="line">        this.age &#x3D; age</span><br><span class="line">        this.address &#x3D; address</span><br><span class="line">    &#125;</span><br><span class="line">    static self()&#123;</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return &quot;[Object Person]&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    getFullName()&#123;</span><br><span class="line">        return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写方法并从另一个类继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Employee.prototype &#x3D; Object.create(Person.prototype)</span><br><span class="line">function Employee(firstName, lastName, age, address, jobTitle, yearStart)&#123;</span><br><span class="line">    Person.call(this, firstName, lastName, age, address)</span><br><span class="line">    this.jobTitle &#x3D; jobTitle</span><br><span class="line">    this.yearStart &#x3D; yearStarted</span><br><span class="line">&#125;</span><br><span class="line">Employee.prototype.describe &#x3D; function () &#123;</span><br><span class="line">return &#96;I am $&#123;this.getFullName()&#125; and I have a position of $&#123;this.jobTitle&#125; and I started at $&#123;this.yearStarted&#125;&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype.toString &#x3D; function () &#123;</span><br><span class="line">return &quot;[object Employee]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 </span><br><span class="line">class Employee extends Person &#123; &#x2F;&#x2F;Inherits from &quot;Person&quot; class</span><br><span class="line">    constructor(firstName, lastName, age, address, jobTitle, yearStarted) &#123;</span><br><span class="line">        super(firstName, lastName, age, address);</span><br><span class="line">        this.jobTitle &#x3D; jobTitle;</span><br><span class="line">        this.yearStarted &#x3D; yearStarted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    describe() &#123;</span><br><span class="line">        return &#96;I am $&#123;this.getFullName()&#125; and I have a position of $&#123;this.jobTitle&#125; and I started at $&#123;this.yearStarted&#125;&#96;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123; &#x2F;&#x2F; Overriding the &quot;toString&quot; method of &quot;Person&quot;</span><br><span class="line">            return &quot;[object Employee]&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以我们要怎么知道它在内部使用原型？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Something &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function AnotherSomething()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">const as &#x3D; new AnotherSomething();</span><br><span class="line">const s &#x3D; new Something();</span><br><span class="line"></span><br><span class="line">console.log(typeof Something); &#x2F;&#x2F; &quot;function&quot;</span><br><span class="line">console.log(typeof AnotherSomething); &#x2F;&#x2F; &quot;function&quot;</span><br><span class="line">console.log(as.toString()); &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line">console.log(as.toString()); &#x2F;&#x2F; &quot;[object Object]&quot;</span><br><span class="line">console.log(as.toString &#x3D;&#x3D;&#x3D; Object.prototype.toString); &#x2F;&#x2F; true</span><br><span class="line">console.log(s.toString &#x3D;&#x3D;&#x3D; Object.prototype.toString); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li><li><p>对象解构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const zhangsan &#x3D; &#123;</span><br><span class="line">    age:12,</span><br><span class="line">    sex:&quot;boy&quot;</span><br><span class="line">&#125;</span><br><span class="line">let &#123;age,sex&#125; &#x3D; zhangsan</span><br><span class="line">let &#123;age:age1,sex&#125; &#x3D; zhangsan &#x2F;&#x2F; 取别名 age为undefined,age1 为12</span><br><span class="line">let &#123; age, sex, hobby &#x3D; &quot;听歌&quot; &#125; &#x3D; zhangsan; &#x2F;&#x2F; 设置默认值，当其属性值为undefined，会使用默认值</span><br></pre></td></tr></table></figure></li><li><p>什么是’Set’对象，它是如何工作的？<br>Set对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>我们可以使用Set构建函数创建Set实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const set1 &#x3D; new Set()</span><br><span class="line">const set2 &#x3D; new Set([1,2,3,3,3,4,4,5,6,6,7])</span><br></pre></td></tr></table></figure><p>我们可以使用add方法向Set实例中添加一个新值，因为add方法返回Set对象，所以我们可以以链式的放法再次使用add。如果一个值已经存在于Set对象中，那么将不会被添加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set2.add(8)</span><br><span class="line">set2.add(9).add(10).add(10)</span><br><span class="line">&#x2F;&#x2F; 后面的10不会被添加到set对象中，因为它已经存在了。</span><br></pre></td></tr></table></figure><p>我们可以使用has方法检查Set实例中是否存在特定的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set2.has(5) &#x2F;&#x2F; true</span><br><span class="line">set2.has(13) &#x2F;&#x2F; fasle</span><br></pre></td></tr></table></figure><p>我们可以使用size属性获得Set实例的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set2.size &#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p>我们可以使用Set对象删除数组中重复的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set2.clear()</span><br></pre></td></tr></table></figure><p>我们可以使用Set对象来删除数组中的重复元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1,2,3,3,4,4]</span><br><span class="line">const uniqueNums &#x3D; [...new Set(numbers)] &#x2F;&#x2F; [1,2,3,4]</span><br></pre></td></tr></table></figure><p>另外还有WeakSet，与Set类似，也是不重复的值的集合。但是WeakSet的成员只能是对象，而不能是其他类型的值。WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。</p><ol><li><p>Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象都可以当做键）。</p></li><li><p>WeakMap 结构与Map结构类似，也是用于生成键值对的集合。但是WeakMap只接受对象作为键名（null除外），不接收其他类型的值最为键名。而且WeakMap的键名所指向的对象，不计入垃圾回收机制。</p></li></ol></li></ul></li></ul><ul><li>Proxy<br>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。<br>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意识代理，用在这里表示由它来“代理某些操作，可以译为“代理器”。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试题</title>
      <link href="/2020/07/25/JS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/07/25/JS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/L9lu0QrO30C3thYH2e2dmg" target="_blank" rel="noopener">原文地址</a></p><ul><li><p>js的数据类型有哪些？是如何存储的。</p><a id="more"></a><p>  基本数据类型分为Null,Undefined,Number,String,Boolean,Symbol(ES6新增),BigInt(ES10新增)<br>  引用数据类型—Object,里面包含Function,Array,Date,RegExp等。JavaScript不支持任何创建自定义类型的机制,所有值都是上述8种数据结构之一。<br>  原始数据类型:直接存放于栈(stack)中,占用空间小,大小固定,属于被频繁使用数据,所以放入栈中存储。<br>  引用数据类型:同时存储与栈(stack)和堆(heap)中,占据空间大,大小不固定.引用数据类型在栈中存储了指针,该指针指向堆中该实体的起始地址。当解释器寻找引用值时,会首先检索其在栈(stack)中的地址,取得地址后在堆(heap)中获得其实体。</p></li><li><p>&amp;&amp;,||和!! 能干什么</p><ol><li>&amp;&amp; 逻辑与,在其操作数中找到第一个虚值并返回它,如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。</li><li>|| 逻辑或，在其操作数中找到找到第一个真值并返回它，也采用了短路来防止不必要的工作。在ES6默认函数参数之前，其用于初始化函数中的默认参数。</li><li>!! 可以将右侧的值强制转化为布尔值,是Boolean()的简写。</li></ol></li><li><p>undefined和undeclared的区别<br>已在作用域中声明但还没赋值的变量，是undefined的。相反，还没有在作用域中声明过的变量，是undeclared的。<br>对于undeclared变量的引用，浏览器会报引用错误，如ReferenceError:b is not defined。但是我们可以使用typeod的安全防范机制来避免报错，因为对于undeclared（或者not defined）变量，typeof会返回“undefined”。</p><ul><li>null和undefined的区别？<br>首先Undefined和Null都是基本数据类型，这两个数据类型分别都只有一个值，就是undefined和null。<br>undefined代表的含义是未定义，<br>null代表的含义是空对象。一般变量声明了但还没有定义的时候会返回undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</li></ul></li></ul><p>undefined在js中不是一个保留字，这意味着我们可以使用undefined来作为一个变量名，这样的做法是非常危险的，它会影响我们对undefined值的判断。但是我们可以通过一些方法获得安全的undefined值，比如说void 0 。</p><p>当我们对两种类型使用typeof进行判断的时候，Null类型会返回“object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回true，使用三个等号时会返回false。</p><ul><li>{}和[]的valueOf和toString的结果是什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;的 valueOf 结果为 &#123;&#125;， toString的结果为&quot;[object object]&quot;</span><br><span class="line">[]的 valueOf 结果为 [],  toString的结果为&quot;&quot;</span><br></pre></td></tr></table></figure></li><li>JavaScript 的作用域 和作用域链<br>作用域：作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量(标识符)进行变量查找。</li></ul><p>作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域练得前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。<br>作用域链的创建过程跟执行上下文的建立有关。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对象的方法</title>
      <link href="/2020/07/25/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/07/25/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>Object.assign() 通过复制一个或多个对象来创建一个新对象。</li><li>Object.create() 使用指定的原型对象和属性创建一个新对象。</li><li>Object.defineProperty() 给对象添加一个属性并指定该属性的配置。</li><li>Object.defaineProperties() 给对象添加多个属性并指定它们的配置。</li><li>Object.entries() 返回给定对象自身可枚举属性的[key,value]数组。</li><li>Object.freeze() 冻结对象:其他代码不能删除或更改任何属性。</li><li>Object.js() 比较两个值是否相同。所有NaN值都相等(这与==和===不同)。</li><li>Object.isExtensible() 判断独享是否可拓展。</li><li>Object.isFrozen() 判断对象是否已经冻结。</li><li>Object.isSealed() 判断对象是否已经密封。</li><li>Object.keys() 返回一个包含所有对象自身可枚举属性名称的数组。</li><li>Object.values() 返回给定对象自身可枚举值的数组。<a id="more"></a></li></ul><ol><li><p>Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const target &#x3D; &#123; a: 1, b: 2 &#125;;</span><br><span class="line">const source &#x3D; &#123; b: 4, c: 5 &#125;;</span><br><span class="line">const returnedTarget &#x3D; Object.assign(target, source);</span><br><span class="line">console.log(target);&#x2F;&#x2F; &#123; a: 1, b: 4, c: 5 &#125;</span><br><span class="line">console.log(returnedTarget); &#x2F;&#x2F; &#123; a: 1, b: 4, c: 5 &#125;</span><br><span class="line">console.log(target &#x3D;&#x3D;&#x3D; returnedTarget) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure></li><li><p>Object.create()方法创建一个新对象,使用现有的对象来提供新创建对象的<strong>proto</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const person&#x3D;&#123;</span><br><span class="line">    isHuman:false,</span><br><span class="line">    printIntroduction:function()&#123;</span><br><span class="line">        console.log(this.isHuman)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const me &#x3D; Object.create(person);</span><br><span class="line">me.name &#x3D; &quot;Mattew&quot; &#x2F;&#x2F; name被设置到me上person没有变</span><br><span class="line">me.isHuman &#x3D; true &#x2F;&#x2F; 属性可以被重写</span><br><span class="line"></span><br><span class="line">me.printIntroduction() &#x2F;&#x2F;true</span><br><span class="line">person.perintIntroduction() &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></li><li><p>Object.defineProperties()方法直接在一个对象上定义新的属性或修改现有属性,并返回该对象。<br>语法 Object.defineProperties(obj, props) obj在其上定义或修改属性的对象。props要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（可参照Object.defineProperty()）。描述符具有以下键:configurabletrue 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应独享中删除。默认为false；emumerabletrue当且仅当在枚举对象上的属性时该属性显现。默认为false；value与属性关联的值。可以是任何有效的JavaScript值(数字，对象，函数等)。默认为undefained；writeabletrue当且仅当与该属性相关联的值可以用assignment operator改变时。默认为false。get作为该属性的getter函数，如果没有getter则为undefined。函数返回值被用作属性的值。默认为undefined；set作为属性的setter函数，如果没有setter则为undefined。函数将仅接受参数赋值给该属性的新值。默认为undefined；返回值节 传递给函数的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj&#x3D;&#123;&#125;</span><br><span class="line">ObjectdefineProperties(obj,&#123;</span><br><span class="line">    &#39;property1&#39;:&#123;</span><br><span class="line">        value:true,</span><br><span class="line">        writeable:true,</span><br><span class="line">        set:function(value)&#123;</span><br><span class="line">            console.log(1)</span><br><span class="line">            this.value&#x3D;value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;property2&#39;:&#123;</span><br><span class="line">        value:&#39;Hello&#39;,</span><br><span class="line">        writeable:false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。<br>语法Object.defineProperty(obj,prop,descriptor) obj要再其上定义属性的对象。prop要定义或修改的属性的名称。descriptor将定义或修改的属性描述符。返回值节  被传递给函数的对象。在ES6中，由于Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty是定义key为Symbol的值来做对象的key与常规的定义或修改不同，而Object.defineProperty是定义key为Symbol的属性的方法之一。</p><ol start="5"><li><p>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用for…in 循环遍历该对象时返回的顺序一致（区别在于for-in循环也枚举原型链中的属性）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const object &#x3D; &#123; name: &#39;zhangsan&#39;, age: 12 &#125;</span><br><span class="line">console.log(Object.entries(object))&#x2F;&#x2F; [[&#39;name&#39;, &#39;zhangsan&#39;], [&#39;age&#39;, 12]]</span><br></pre></td></tr></table></figure></li><li><p>Object.freeze()方法可以冻结一个对象。一个被冻结的对象再也不能被修改;冻结一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举型、可配置性、可写行,以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze()返回和传入的参数相同的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;name: &#39;张三&#39;, age: 12 &#125;</span><br><span class="line">const person2 &#x3D; Object.freeze(person)</span><br><span class="line">person.name &#x3D; &#39;李四&#39; &#x2F;&#x2F; &#123;name: &#39;张三&#39;, age: 12 &#125;</span><br><span class="line">person &#x3D;&#x3D;&#x3D; person2 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Object.fromEntries()把键值对列表转换为一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Map 转化为 Object</span><br><span class="line">通过 Object.fromEntries,可以将Map转化为Object</span><br><span class="line"></span><br><span class="line">const map &#x3D; new Map([ [&#39;name&#39;, &#39;张三&#39;], [&#39;age&#39;, 12]])</span><br><span class="line">const obj &#x3D; Object.fromEntries(map)</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;name: &quot;张三&quot;, age: 12&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Array 转化为 Object</span><br><span class="line">const arr &#x3D; [ [&#39;0&#39;, &#39;a&#39;], [&#39;1&#39;, &#39;b&#39;], [&#39;2&#39;, &#39;c&#39;]]</span><br><span class="line">const obj1 &#x3D; Object.fromEntries(arr) &#x2F;&#x2F; &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class="line"></span><br><span class="line">对象转换为 Object</span><br><span class="line">Object.fromEntries 是 Object.entries()的反转函数，借用 array  manipulation methods 可以转化对象</span><br><span class="line"></span><br><span class="line">const object1 &#x3D; &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line"> </span><br><span class="line">const object2 &#x3D; Object.fromEntries(</span><br><span class="line">  Object.entries(object1)</span><br><span class="line">  .map(([ key, val ]) &#x3D;&gt; [ key, val * 2 ])</span><br><span class="line">); &#x2F;&#x2F; &#123;a: 2, b: 4, c: 6&#125;</span><br></pre></td></tr></table></figure></li><li><p>Onject.is()方法判断两个值是否是相同的值<br>Object.is(‘foo’, ‘foo’); // true<br>Object.is(window, window); // true<br>Object.is(‘foo’, ‘bar’); // false<br>Object.is([], []) // false </p></li></ol><p>var foo = { a: 1};<br>var bar = { a: 1};<br>Object.is(foo, foo) // true<br>Object.is(foo, bar) // true<br>Object.is(null, null) // true</p><p>Object.is(0, -0); // false<br>Object.is(-0, -0); // true<br>Object.is(NaN, 0/0); // true</p><ol start="9"><li>Onject.isForzen() 方法判断一个对象是否被冻结<br>// 使用 Object.freeze 是冻结一个对象最方便的方法。<br>var frozen = { a:1 };<br>Object.isForzen(forzen); // === false<br>Object.freeze(forzen);<br>Object.isForzen(frozen); // === true</li></ol><p>// 一个冻结对象也是一个密封对象。<br>Object.isSealed(forzen) // === true</p><p>// 当然更是一个不可拓展对象<br>Object.isExtensible(forzen) // === false<br>在ES5中,如果参数不是一个对象类型,将跑出一个TypeError异常。在ES2015中, 非对象参数将被视为一个冻结的普通对象,因此会返回true。</p><p>Object.isFrozen(1);<br>// TypeError: 1 is not an object (ES5 code)</p><p>Object.isFrozen(1);<br>// true (ES2015 code)</p><ol start="10"><li>Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组,数组中属性名的排列顺序和试用for…in 循环遍历该对象时返回的顺序一致。<br>// simple array<br>var arr = [‘a’, ‘b’, ‘c’];<br>console.log(Object.keys(arr)); // [‘0’, ‘1’, ‘2’]</li></ol><p>// array like object<br>var obj = {0: ‘a’, 1: ‘b’, 2: ‘c’};<br>console.log(Object.keys(obj)); // [‘0’, ‘1’, ‘2’]</p><p>// array like object with random key ordering<br>var anObj = {100: ‘a’, 2: ‘b’, 7: ‘c’};<br>console.log(Object.keys(anObj)); // [‘2’, ‘7’, ‘100’]</p><p>// getFoo is a property which isn’t enumerable<br>var myObj = Object.create({}, {<br>    getFoo: {<br>        value: function (){ return this.foo};<br>    }<br>});<br>myObj.foo = 1;<br>console.log(Object.keys(myObj)); // [‘foo’]</p><ol start="11"><li>Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同(区别在于for…in循环枚举原型链中的属性)</li></ol><p>var onj = {foo :’bar’, baz: 42};<br>console.log(Object.Values(obj)); // [‘bar’, 42]</p><p>// array like object<br>var obj = { 0: ‘a’, 1: ‘b’, 2: ‘c’};<br>console.log(Object.values(obj)); // [‘a’, ‘b’, ‘c’]</p><p>// array like object with random key ordering</p><p>// when we use numeric keys, the value returned in a numerical order according to the keys</p><p>var an_obj = {100: ‘a’, 2: ‘b’, 7: ‘c’};<br>console.log(Object.values(an_obj)); // [‘b’, ‘c’, ‘a’]</p><p>// getFoo is property which isn’t enumerable</p><p>var my_obj = Object.create({}, {getFoo:{value:function(){ return this.foo; }}});</p><p>my_obj.foo = ‘bar’;<br>console.log(Object.values(my_obj)); // [‘bar’]</p><p>// non-object argument will be coerced to an object<br>console.log(Object.values(‘foo’)); // [‘f’, ‘o’, ‘o’]</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sass的基本使用</title>
      <link href="/2020/07/01/sass%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/01/sass%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>定义变量<a id="more"></a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$width: 200px;</span><br></pre></td></tr></table></figure><pre><code>1. $：声明变量的符号2. width： 变量的名称3. 300px： 变量值</code></pre><ul><li>变量的默认值与普通变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$height: 200px;</span><br><span class="line">$height: 300px !default;</span><br><span class="line">div&#123;</span><br><span class="line">    height: $height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译后的css为</span><br><span class="line">div&#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. sass的默认变量一般用来设置默认值，然后根据需求进行覆盖，覆盖的方式很简单，只需要在默认变量 __之前__ 重新声明下变量即可。</code></pre><ul><li>全局变量和局部变量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$color: red; &#x2F;&#x2F; 定义全局表示变量</span><br><span class="line">h1&#123;</span><br><span class="line">    color: $color; &#x2F;&#x2F; 调用全局变量</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    $color: blue; &#x2F;&#x2F; 定义局部变量</span><br><span class="line">    span&#123;</span><br><span class="line">        color: $color; &#x2F;&#x2F; 调用局部变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>什么时候声明变量<ul><li>该值至少出现了2次。</li><li>该值至少可能会被更新一次。</li><li>该值所有的表现都与变量有关（非巧合）</li></ul></li></ol><ul><li><p>选择器嵌套</p><p>  例如当有这样的html时</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">        &lt;a&gt;1&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;a&gt;2&lt;&#x2F;a&gt;</span><br><span class="line">        &lt;a&gt;3&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;&#x2F;nav&gt;</span><br><span class="line">&lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure><p>  Sass中可以这样写</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nav&#123;</span><br><span class="line">    a&#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    header &amp;&#123;</span><br><span class="line">        color: green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  编译成的css是这样的</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nav a&#123; color: red; &#125;</span><br><span class="line">header nac a&#123; color: blue; &#125;</span><br></pre></td></tr></table></figure></li><li><p>属性嵌套<br>  当对font-size，font-weight同时进行设置时Sass可以这样写</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p&#123;</span><br><span class="line">    font: &#123;</span><br><span class="line">        size:12px;</span><br><span class="line">        weight:bold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  编译为css</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123; font-size: 12px; font-weight: bold; &#125;</span><br></pre></td></tr></table></figure></li><li><p>伪类嵌套</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.clearfix&#123;</span><br><span class="line">    &amp;:before,</span><br><span class="line">    &amp;:after&#123;</span><br><span class="line">        content:&#39;&#39;;</span><br><span class="line">        display:table;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;:after&#123;</span><br><span class="line">        clear:both;</span><br><span class="line">        overflow:hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  编译出来的css为</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:before, .clearfix:after&#123;</span><br><span class="line">    content:&quot;&quot;;</span><br><span class="line">    display:table;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after&#123;</span><br><span class="line">    cleear:both;</span><br><span class="line">    overflow:hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>避免选择器嵌套</p><ul><li>选择器最大的问题是将最终的代码难以阅读。开发者需要巨大精力计算不同缩进级别下的选择器具体的表现效果。</li><li>选择器越具体则声明语句越冗长，而且对最近选择器的引用（&amp;）也越频繁。在某些时候，出现混淆选择器路径和探索下一级选择器的错误率很高，这非常不值得。</li></ul></li></ol></li><li><p>声明混合宏</p></li></ul><ol><li><p>不带参数的混合宏</p><p> 在Sass中使用“@mixin”声明一个混合宏,例如：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@mixin border-radius&#123;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带参数的混合宏</p><ul><li><p>无默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin border-radius($radius)&#123;</span><br><span class="line">    -webkit-border-radius:$radius;</span><br><span class="line">    border-radius:$radius;</span><br><span class="line">&#125;</span><br><span class="line">* 有默认值</span><br></pre></td></tr></table></figure><p>@mixin border-radius($radius:5px){<br>  -webkit-border-radius:$radius;<br>  border-radius:$radius;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 复杂的混合宏</span><br></pre></td></tr></table></figure><p>@mixin box-shadow($shadow…){<br>  @if length($shadow)&gt;=1{</p><pre><code>@inclue prefixer(box-shadow, $shadow);</code></pre><p>  }@else{</p><pre><code>$shadow:0 0 4px ragb(0, 0, 0, 0.3);@inclue prefixer(box-shadow, $shadow);</code></pre><p>  }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    这个box-shadow的混合宏，带有多个参数，这个时候可以使用“...”来替代。当$shadow的参数值值大于或等于“1”时，表示有多个阴影值，反之调用默认值“:0 0 4px ragb(0, 0, 0, 0.3)”</span><br><span class="line"></span><br><span class="line">- 调用混合宏</span><br><span class="line">    在Sass中通过@mixin关键字声明了一个混合宏，那么在实际调用中，其匹配了一个关键字“@include”来调用声明好的混合宏。例如在样式中定义了圆角混合宏：</span><br></pre></td></tr></table></figure><p>@mixin border-radius($radius:5px){<br>  -webkit-border-radius:$radius;<br>  border-radius:$radius;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在button中使用时：</span><br></pre></td></tr></table></figure><p>button{<br>  @include border-radius;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编译出来的css为</span><br><span class="line">button&#123;</span><br><span class="line">    -webkit-border-radius:5px;</span><br><span class="line">    border-radius:5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在div中使用</span><br></pre></td></tr></table></figure><p>div{<br>  @inclue border-radius(10px);<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译出来的css为</span><br></pre></td></tr></table></figure><p>div{<br>  -webkit-border-radius:10px;<br>  border-radius:10px;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 传多个参数</span><br><span class="line"></span><br><span class="line">    Sass混合宏除了可以传1个参数，还可以传多个参数。</span><br></pre></td></tr></table></figure><p>@mixin center($width, $height){<br>  width: $width;<br>  height: $height;<br>  position: absolute;<br>  top: 50%;<br>  left: 50%;<br>  margin-top: -($height) / 2;<br>  margin-left: - ($width) / 2; </p><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用</span><br></pre></td></tr></table></figure><p>.box-shadow{<br>  @include center(500px, 300px)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译出来的css</span><br></pre></td></tr></table></figure><p>.box-shadow{<br>  width: 500px;<br>  height: 100px;<br>  position: absolut;<br>  top: 50%;<br>  left: 50%;<br>  margin-left: -150px;<br>  margin-top: -250px;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 继承</span><br><span class="line"></span><br><span class="line">    在Sass中具有继承一说，也是继承类中的样式代码块。在Sass中通过关键字“@extend”来继承已存在的类样式块，从而实现代码的继承。例如：</span><br></pre></td></tr></table></figure><p>.btn{<br>  border:1px solid #ccc;<br>  paddign:6px 10px;<br>  font-size:14px;<br>}<br>.btn-primary{<br>  background-color:#666;<br>  color:#fff;<br>  @extend: .btn;<br>}<br>.btn-second{<br>  background-color:orange;<br>  color:#fff;<br>  @extend: .btn;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译出来的代码</span><br></pre></td></tr></table></figure><p>.btn, .btn-primary, .btn-second{<br>  border:1px solid #ccc;<br>  paddign:6px 10px;<br>  font-size:14px;<br>}<br>.btn-primary{<br>  background-color:#666;<br>  color:#fff;<br>}<br>.btn-second{<br>  background-color:orange;<br>  color:#fff;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 占位符 %placeholder</span><br><span class="line"></span><br><span class="line">    Sass的占位符%plaacholder功能是一个很强大，很实用的功能。他可以取代以前CSS中的基类造成的代码冗余的情形。因为%placeholder生命的代码如果不被@extend调用的话，不会产生任何代码块。只有在被@extend调用才会产生代码块。</span><br></pre></td></tr></table></figure><p>  %mt5{ margin-top:5px; }<br>  %pt5{ padding-top:5px; }<br>  .btn{</p><pre><code>@extend %mt5;@extend %mp5;</code></pre><p>  }<br>  .block{</p><pre><code>@extend %mt5;span{    @extend %pt5;}</code></pre><p>  }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编译出来的css代码</span><br></pre></td></tr></table></figure><p>.btn, .block{<br>  margin-top:5px;<br>}<br>.btn, .block span{<br>  margin-padding:5px;<br>}</p><pre><code>通过@extend调用的占位符，编译出来的代码会将相同的代码合并到一块，会让css文件更加干净。</code></pre></li></ul></li></ol><ul><li><p>混合宏VS继承VS占位符</p><ol><li>Sass中混合宏的使用<br>编译出来的CSS清晰告诉了大家，他不会合并相同的样式代码，如果样式文件中调用同一个混合宏，会产生对各对应的样式代码，造成代码冗余。但是其可以传参数。<br>如果代码块中涉及到变量，建议使用混合宏来创建。</li><li>Sass中继承<br>在使用继承后，编译出来的css会将使用继承的代码块合并到一起，通过组合</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Sass </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15个必须知道的数组方法</title>
      <link href="/2020/06/11/15%E4%B8%AA%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/11/15%E4%B8%AA%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><ul><li>some()</li><li>every()</li><li>reduce()</li><li>map()</li><li>flat()</li><li>filter()</li><li>forEach()</li><li>findIndex()</li><li>find()</li><li>sort()</li><li>concat()</li><li>fill()</li><li>includes()</li><li>reverse()</li><li>flatMap()<a id="more"></a></li></ul><ol><li><p>some()<br>用于参数传递的函数测试数组。如果有一个元素与测试元素匹配，则返回true，否则返回false。(some()不对空数组进行检测;some()不会改变原始数组;some需要传入一个函数,需要return)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3,4,5]</span><br><span class="line">arr.some(item&#x3D;&gt;&#123; return item &gt; 4 &#125;) &#x2F;&#x2F;true</span><br><span class="line">arr.some(item&#x3D;&gt;&#123; return item &gt; 9 &#125;) &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></li><li><p>every()<br>用于参数传递的函数测试数组。如果数组的每个元素都与测试匹配,则返回true,否则返回false。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const arr&#x3D;[1,2,3,4,5]</span><br><span class="line">arr.every(item&#x3D;&gt;&#123; return item &gt; 0 &#125;) &#x2F;&#x2F;true</span><br><span class="line">arr.every(item&#x3D;&gt;&#123; return item &gt; 3 &#125;) &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></li><li><p>reduce()<br>接收一个函数作为累加器。它为数组中的每个元素依次执行回调函数，不包括数组中被删除或者从未被赋值的元素。函数应用于累加器，数组中的每个值最后只返回一个值。<br>reduce()接受4个参数：初始值(上一个回调的返回值),当前元素值,当前元素，原数组</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1,2,3,4,5]</span><br><span class="line">arr.reduce((a,b)&#x3D;&gt;&#123; return a+b &#125;)</span><br></pre></td></tr></table></figure></li><li><p>map()<br>该方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值，它按照原始数组元素顺序依次处理元素。(map()不会对空数组进行检测，map()不会改变原始数组)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3,4,5]</span><br><span class="line">const arr2&#x3D;arr.map(item&#x3D;&gt;&#123;return item+1&#125;)</span><br><span class="line">arr2 &#x3D; [2,3,4,5,6]</span><br></pre></td></tr></table></figure></li><li><p>flat()<br>该方法创建一个新数组，其中包含子数组上的holden元素，并将其凭证到新数组中。(该方法只能进行一个级别的深度)。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[[1,2],[3,4]]</span><br><span class="line">const arr2&#x3D;arr.flat() &#x2F;&#x2F; [1,2,3,4]</span><br><span class="line">const arr3&#x3D;[[1,[2,3]],[3,4]]</span><br><span class="line">const arr4&#x3D;arr3.flat() &#x2F;&#x2F;[1,[2,3],3,4]</span><br></pre></td></tr></table></figure></li><li><p>filter()<br>该方法接收一个函数作为参数，并返回一个新数组，该数组包含该数组的所有元素，作为函数传递的过滤函数对其返回true。(filter()方法是对数据中的元素进行过滤，也就是说不能修改原数组中的数据，只能读取原数组中的数组，callback需要返回布尔值；为true的时候，对应的元素留下；为false的时候，对应的元素过滤掉)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3,4,5]</span><br><span class="line">const arr2&#x3D; arr.filter(item&#x3D;&gt;&#123;return item&gt;3&#125;) &#x2F;&#x2F; [4,5]</span><br></pre></td></tr></table></figure></li><li><p>forEach()<br>该方法用于调用数组的每个元素。并将元素传递给回调函数。(forEach()不对空数组执行回调函数)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3,4]</span><br><span class="line">arr.forEach(item&#x3D;&gt;&#123;console.log(item)&#125;)</span><br></pre></td></tr></table></figure></li><li><p>findIndex()<br>此方法返回传入一个测试条件(函数)符合条件的数组的第一个元素位置。它为数组中的每个元素都调用一次函数执行，当数组中的元素在测试条件时返回true时，findIndex()返回符合条件的元素的索引位置,之后的值不会再调用执行函数。如果没有符合的元素返回-1。(findIndex()对于空数组,函数是不会执行的,findIndex()并没有改变数组的原始值)</p></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3,4]</span><br><span class="line">arr.findIndex(item&#x3D;&gt;&#123;return item&gt;2&#125;)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure></code></pre><ol start="9"><li><p>find()<br>该方法返回通过测试(函数内判断)的数组的第一个元素的值。find()方法为数组中的每个元素都调用一次函数执行；当数组中的元素在测试条件时,返回true时，find()返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回undefined。(find()对于空数组不会执行函数；find()并没有改变数组的原始值。)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[&#123;name:&#39;张三&#39;,age:11&#125;,&#123;name:&#39;李四&#39;,age:11&#125;,&#123;name:&#39;王五&#39;,age:12&#125;,&#123;name:&#39;韩六&#39;,age:13&#125;]</span><br><span class="line">const obj&#x3D;arr.find(item&#x3D;&gt;&#123;return item.age&gt;11&#125;)&#x2F;&#x2F;&#123;name:&#39;王五&#39;,age:12&#125;</span><br></pre></td></tr></table></figure></li><li><p>sort()<br>此方法接收一个函数作为参数。它对数组的元素进行排序并返回它。也可以使用含有参数的sort()方法进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3,4,5]</span><br><span class="line">arr.sort((a,b)&#x3D;&gt;&#123;return a-b&#125;)</span><br></pre></td></tr></table></figure></li><li><p>concat()<br>此方法用于连接两个或多个数组/值，它不会改变现有的数组。而仅仅返回被连接数组的一个新数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2]</span><br><span class="line">const arr1&#x3D;[3,4]</span><br><span class="line">const arr2&#x3D;[5,6]</span><br><span class="line">const arr3&#x3D;arr.concat(arr1,arr2) &#x2F;&#x2F;[1,2,3,4,5,6]</span><br></pre></td></tr></table></figure></li><li><p>fill()<br>此方法的作用是使用一个固定值来替换数组中的元素。该固定值可以是字母/数字/字符串/数组等等。它还有两个可选参数，表示填充起来的开始位置(默认为0)与结束位置(默认为arr.lengrth).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3,4,5,6,7,8]</span><br><span class="line">arr.fill(&#39;test&#39;,2,5) &#x2F;&#x2F; [1, 2, &quot;test&quot;, &quot;test&quot;, &quot;test&quot;, 6, 7, 8]</span><br></pre></td></tr></table></figure></li><li><p>includes()<br>此方法用于判断字符是否包含指定的子字符串。如果找到匹配的字符串则返回true,否则返回false。(includes()区分大小写)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const arr &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">arr.includes(3) &#x2F;&#x2F; true </span><br><span class="line">arr.includes(8) &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></li><li><p>reverse()<br>此方法用于颠倒数组中元素的顺序。第一个元素成为最后一个，最后一个将成为第一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[1,2,3,4,5,6]</span><br><span class="line">arr.reverse()</span><br></pre></td></tr></table></figure></li><li><p>flatMap()<br>此方法将函数应用于数组的每个元素，然后将结果压缩为一个新数组。他在一个函数中结合了flat()和map()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr&#x3D;[[1],[2],[3],[4]]</span><br><span class="line">arr.flatMap(item&#x3D;&gt;&#123;return item + 1&#125;)  &#x2F;&#x2F; [&quot;11&quot;, &quot;21&quot;, &quot;31&quot;, &quot;41&quot;]</span><br><span class="line"></span><br><span class="line">const arr2&#x3D;[[1],[2],[3],[4]]</span><br><span class="line">arr.flatMap(item&#x3D;&gt;item*10)  &#x2F;&#x2F;  [10, 20, 30, 40]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Squelize 使用步骤</title>
      <link href="/2020/06/10/Squelize-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4/"/>
      <url>/2020/06/10/Squelize-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>用于记录sequlize的使用</p><a id="more"></a><ul><li><p>初始化项目,生成package.json</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li><li><p>安装express  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i express -S</span><br><span class="line">npm install express-generator -g</span><br><span class="line">npm --view&#x3D;ejs blog &#x2F;&#x2F;指定ejs模板引擎生成模板，后跟项目名</span><br></pre></td></tr></table></figure></li><li><p>进入项目</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">DEBUG&#x3D;bolg;* npm start</span><br></pre></td></tr></table></figure></li><li><p>安装sequelize </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sequelize -S</span><br></pre></td></tr></table></figure></li><li><p>安装mysql2</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql2 -S</span><br></pre></td></tr></table></figure></li><li><p>安装sequelize-cli</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sequelize-cli -g</span><br></pre></td></tr></table></figure></li><li><p>初始化项目目录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequlize init</span><br></pre></td></tr></table></figure></li><li><p>目录介绍 </p><table><thead><tr><th align="center">文件</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">config</td><td align="center">数据配置</td></tr><tr><td align="center">Migration</td><td align="center">迁移文件，用于新增数据库表等</td></tr><tr><td align="center">Models</td><td align="center">模型</td></tr><tr><td align="center">Seeders</td><td align="center">用于添加测试数据</td></tr></tbody></table></li><li><p>创建数据库</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequlize db:create --charset &#39;utf8mb4&#39;</span><br></pre></td></tr></table></figure></li><li><p>建model和迁移文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seqiulize model:generate --name Article -- attributes title:string,content:text</span><br></pre></td></tr></table></figure></li><li><p>运行迁移，生成数据表</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequelize db:migrate</span><br></pre></td></tr></table></figure></li><li><p>建种子文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequlize seed:generate --name article</span><br></pre></td></tr></table></figure></li><li><p>在seeders文件夹下，运行迁移</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequlize db:seed:all</span><br></pre></td></tr></table></figure></li><li><p>在routers中复制index.js修改为articel.js</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);</span><br><span class="line">var router &#x3D; express.Router();</span><br><span class="line">var models&#x3D;require(&#39;..&#x2F;models&#39;)</span><br><span class="line">const secret &#x3D; &#39;my&#39;;</span><br><span class="line">&#x2F;* GET home page. *&#x2F;</span><br><span class="line">router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123;</span><br><span class="line">res.render(&#39;index&#39;, &#123; title: &#39;Express&#39; &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">module.exports &#x3D; router;</span><br></pre></td></tr></table></figure></li><li><p>app.js中操作</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const articleRouter &#x3D; require(&#39;.&#x2F;article&#x2F;index&#39;)</span><br><span class="line">app.use(&#39;&#x2F;api&#x2F;aricle&#39;,articleRouter)</span><br></pre></td></tr></table></figure></li></ul><ul><li>使用nodemon热更新服务器<ol><li>安装nidemon <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm nodemon -S</span><br></pre></td></tr></table></figure></li><li>修改package.json配置文件<br> 将<br> script:{<pre><code>&apos;dev&apos;:&apos;node app.js&apos;</code></pre> }<br> 修改为<br> script:{<pre><code>&apos;dev&apos;:&apos;nodemon app.js&apos;</code></pre> }</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Sequelize </tag>
            
            <tag> Sequelize-cli </tag>
            
            <tag> nodemon </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Date对象的方法</title>
      <link href="/2020/06/09/Date%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/09/Date%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>关于Date对象的方法记录</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Date()返回当日的日期和时间。</span><br><span class="line">getDate()从 Date 对象返回一个月中的某一天 (1 ~ 31)。</span><br><span class="line">getDay()从 Date 对象返回一周中的某一天 (0 ~ 6)。</span><br><span class="line">getMonth()从 Date 对象返回月份 (0 ~ 11)。</span><br><span class="line">getFullYear()从 Date 对象以四位数字返回年份。</span><br><span class="line">getYear()请使用 getFullYear() 方法代替。</span><br><span class="line">getHours()返回 Date 对象的小时 (0 ~ 23)。</span><br><span class="line">getMinutes()返回 Date 对象的分钟 (0 ~ 59)。</span><br><span class="line">getSeconds()返回 Date 对象的秒数 (0 ~ 59)。</span><br><span class="line">getMilliseconds()返回 Date 对象的毫秒(0 ~ 999)。</span><br><span class="line">getTime()返回 1970 年 1 月 1 日至今的毫秒数。</span><br><span class="line">getTimezoneOffset()返回本地时间与格林威治标准时间 (GMT) 的分钟差。</span><br><span class="line">getUTCDate()根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</span><br><span class="line">getUTCDay()根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</span><br><span class="line">getUTCMonth()根据世界时从 Date 对象返回月份 (0 ~ 11)。</span><br><span class="line">getUTCFullYear()根据世界时从 Date 对象返回四位数的年份。</span><br><span class="line">getUTCHours()根据世界时返回 Date 对象的小时 (0 ~ 23)。</span><br><span class="line">getUTCMinutes()根据世界时返回 Date 对象的分钟 (0 ~ 59)。</span><br><span class="line">getUTCSeconds()根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</span><br><span class="line">getUTCMilliseconds()根据世界时返回 Date 对象的毫秒(0 ~ 999)。</span><br><span class="line">parse()返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</span><br><span class="line">setDate()设置 Date 对象中月的某一天 (1 ~ 31)。</span><br><span class="line">setMonth()设置 Date 对象中月份 (0 ~ 11)。</span><br><span class="line">setFullYear()设置 Date 对象中的年份（四位数字）。</span><br><span class="line">setYear()请使用 setFullYear() 方法代替。</span><br><span class="line">setHours()设置 Date 对象中的小时 (0 ~ 23)。</span><br><span class="line">setMinutes()设置 Date 对象中的分钟 (0 ~ 59)。</span><br><span class="line">setSeconds()设置 Date 对象中的秒钟 (0 ~ 59)。</span><br><span class="line">setMilliseconds()设置 Date 对象中的毫秒 (0 ~ 999)。</span><br><span class="line">setTime()以毫秒设置 Date 对象。</span><br><span class="line">setUTCDate()根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</span><br><span class="line">setUTCMonth()根据世界时设置 Date 对象中的月份 (0 ~ 11)。</span><br><span class="line">setUTCFullYear()根据世界时设置 Date 对象中的年份（四位数字）。</span><br><span class="line">setUTCHours()根据世界时设置 Date 对象中的小时 (0 ~ 23)。</span><br><span class="line">setUTCMinutes()根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</span><br><span class="line">setUTCSeconds()根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</span><br><span class="line">setUTCMilliseconds()根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</span><br><span class="line">toSource()返回该对象的源代码。</span><br><span class="line">toString()把 Date 对象转换为字符串。</span><br><span class="line">toTimeString()把 Date 对象的时间部分转换为字符串。</span><br><span class="line">toDateString()把 Date 对象的日期部分转换为字符串。</span><br><span class="line">toGMTString()请使用 toUTCString() 方法代替。</span><br><span class="line">toUTCString()根据世界时，把 Date 对象转换为字符串。</span><br><span class="line">toLocaleString()根据本地时间格式，把 Date 对象转换为字符串。</span><br><span class="line">toLocaleTimeString()根据本地时间格式，把 Date 对象的时间部分转换为字符串。</span><br><span class="line">toLocaleDateString()根据本地时间格式，把 Date 对象的日期部分转换为字符串。</span><br><span class="line">UTC()根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</span><br><span class="line">valueOf()返回 Date 对象的原始值。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>按需加载的方式</title>
      <link href="/2020/06/06/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/06/06/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="vue路由按需加载"><a href="#vue路由按需加载" class="headerlink" title="vue路由按需加载"></a>vue路由按需加载</h3><p>普通加载的缺点：<br>webpack在打包时会把整个路由文件打包成一个js文件，如果页面一多，这个js文件会非常大,加载缓慢。</p><a id="more"></a><p>在使用vue-cli时，利用Router时,会在router.js中引入各种组件,例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Hello from &#39;@&#x2F;components&#x2F;Hello&#39;</span><br><span class="line">import Boy from &#39;@&#x2F;components&#x2F;Boy&#39;</span><br><span class="line">import Girl from &#39;@&#x2F;components&#x2F;Girl&#39;</span><br></pre></td></tr></table></figure><h4 id="普通加载的缺点"><a href="#普通加载的缺点" class="headerlink" title="普通加载的缺点"></a>普通加载的缺点</h4><p>webpack在打包时会把整个路由文件打包成一个js文件，如果页面一多，这个js文件会非常大,加载缓慢。</p><ol><li>require.ensure()  实现按需加载<ul><li>语法  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require.ensuire(dependencies:String[],callback:function(require),errorCallback:function(error),chunkName:String)</span><br></pre></td></tr></table></figure></li><li>实际案例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const List &#x3D; resolve &#x3D;&gt; &#123; require.ensure([]), () &#x3D;&gt; &#123; resolve(required(&#39;.&#x2F;list&#39;)) &#125;, list &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>vue异步组件技术<br>在router中配置,使用这种方式可以实现按需加载,一个组件生成一个js文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#39;&#x2F;home&#39;,</span><br><span class="line">    name: &#39;home&#39;,</span><br><span class="line">    component: resove &#x3D;&gt; require([&#39;@&#x2F;components&#x2F;home&#39;],resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用动态的import()语法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const router &#x3D; new VueRouter(&#123;</span><br><span class="line">    routers: [</span><br><span class="line">        &#x2F;&#x2F; 没有指定webpackChunkName,每个组件打包成一个js文件</span><br><span class="line">        &#123; path: &#39;.&#x2F;test1&#39;, name: &#39;test1&#39;, component: () &#x3D;&gt;&#123; import(&#39;@&#x2F;components&#x2F;test1.vue&#39;) &#125; &#125;,</span><br><span class="line">        &#123; path: &#39;.&#x2F;test2&#39;, name: &#39;test2&#39;, component: () &#x3D;&gt;&#123; import(&#39;@&#x2F;components&#x2F;test2.vue&#39;) &#125; &#125;,</span><br><span class="line">        &#x2F;&#x2F; 指定了相同的webpackChunkName,会合并打包成一个js文件</span><br><span class="line">        &#x2F;&#x2F; 使用命名chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)</span><br><span class="line">        &#123; path: &#39;.&#x2F;test3&#39;, name: &#39;test3&#39;, component: () &#x3D;&gt;&#123; webpackChunkName:&#39;grounpTest&#39;, import(&#39;@&#x2F;components&#x2F;test3.vue&#39;) &#125; &#125;,</span><br><span class="line">        &#123; path: &#39;.&#x2F;test4&#39;, name: &#39;test4&#39;, component: () &#x3D;&gt;&#123; webpackChunkName:&#39;grounpTest&#39;, import(&#39;@&#x2F;components&#x2F;test4.vue&#39;) &#125; &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 按需加载 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios的封装</title>
      <link href="/2020/06/01/axios%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/2020/06/01/axios%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="vue中基于axios的二次封装-一"><a href="#vue中基于axios的二次封装-一" class="headerlink" title="vue中基于axios的二次封装(一)"></a>vue中基于axios的二次封装(一)</h3><p>本文记录的axios的二次封装，一种简单封装，一种符合更多场景的封装。</p><a id="more"></a><ul><li><p>在src文件夹下新建api文件夹，新建request.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const _errno &#x3D; 1</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"></span><br><span class="line">export function get(url) &#123;</span><br><span class="line">    return function (params) &#123;</span><br><span class="line">        return axios.get(url, &#123;</span><br><span class="line">            params</span><br><span class="line">        &#125;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">            const &#123; errno, data &#125; &#x3D;res.data</span><br><span class="line">            if(errno &#x3D; _errno )&#123; &#x2F;&#x2F;对数据进行判断 是否正确</span><br><span class="line">                return data</span><br><span class="line">            &#125;                       </span><br><span class="line">        &#125;).catch(() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在api文件夹新建index.js</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; get &#125; from &#39;.&#x2F;request.js&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const getNews &#x3D; get(&#39;&#x2F;api&#x2F;v1&#x2F;news&#39;)</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    getNews</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123; getNews &#125; from &#39;api&#39;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line"></span><br><span class="line">    getData()&#123;</span><br><span class="line">        getNews().then((res) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于axios-的二次封装-二"><a href="#基于axios-的二次封装-二" class="headerlink" title="基于axios 的二次封装(二)"></a>基于axios 的二次封装(二)</h3></li><li><p>对request拦截器、response拦截器、统一的错误处理、统一做了超时处理、baseURL等统一进行了封装</p></li><li><p>新建api文件夹，新建request.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line"></span><br><span class="line">import &#123; MessageBox, Message &#125; from &#39;element-ui&#39;</span><br><span class="line"></span><br><span class="line">import store from &#39;@&#x2F;store&#39;</span><br><span class="line"></span><br><span class="line">import &#123; getToken &#125; from &#39;@&#x2F;utils&#x2F;auth&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create an axios instance</span><br><span class="line"></span><br><span class="line">const service &#x3D; axios.create(&#123;</span><br><span class="line"></span><br><span class="line">  baseURL: process.env.VUE_APP_BASE_API, &#x2F;&#x2F; url &#x3D; base url + request url</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; withCredentials: true, &#x2F;&#x2F; send cookies when cross-domain requests</span><br><span class="line"></span><br><span class="line">  timeout: 5000 &#x2F;&#x2F; request timeout</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; request interceptor</span><br><span class="line"></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line"></span><br><span class="line">  config &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; do something before request is sent</span><br><span class="line"></span><br><span class="line">    if (store.getters.token) &#123;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; let each request carry token</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; [&#39;X-Token&#39;] is a custom headers key</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; please modify it according to the actual situation</span><br><span class="line"></span><br><span class="line">      config.headers[&#39;X-Token&#39;] &#x3D; getToken()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return config</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; do something with request error</span><br><span class="line"></span><br><span class="line">    console.log(error) &#x2F;&#x2F; for debug</span><br><span class="line"></span><br><span class="line">    return Promise.reject(error)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; response interceptor</span><br><span class="line"></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"></span><br><span class="line">   * If you want to get http information such as headers or status</span><br><span class="line"></span><br><span class="line">   * Please return  response &#x3D;&gt; response</span><br><span class="line"></span><br><span class="line">  *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"></span><br><span class="line">   * Determine the request status by custom code</span><br><span class="line"></span><br><span class="line">   * Here is just an example</span><br><span class="line"></span><br><span class="line">   * You can also judge the status by HTTP Status Code</span><br><span class="line"></span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  response &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const res &#x3D; response.data</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; if the custom code is not 20000, it is judged as an error.</span><br><span class="line"></span><br><span class="line">    if (res.code !&#x3D;&#x3D; 20000) &#123;</span><br><span class="line"></span><br><span class="line">      Message(&#123;</span><br><span class="line"></span><br><span class="line">        message: res.message || &#39;Error&#39;,</span><br><span class="line"></span><br><span class="line">        type: &#39;error&#39;,</span><br><span class="line"></span><br><span class="line">        duration: 5 * 1000</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired;</span><br><span class="line"></span><br><span class="line">      if (res.code &#x3D;&#x3D;&#x3D; 50008 || res.code &#x3D;&#x3D;&#x3D; 50012 || res.code &#x3D;&#x3D;&#x3D; 50014) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; to re-login</span><br><span class="line"></span><br><span class="line">        MessageBox.confirm(&#39;You have been logged out, you can cancel to stay on this page, or log in again&#39;, &#39;Confirm logout&#39;, &#123;</span><br><span class="line"></span><br><span class="line">          confirmButtonText: &#39;Re-Login&#39;,</span><br><span class="line"></span><br><span class="line">          cancelButtonText: &#39;Cancel&#39;,</span><br><span class="line"></span><br><span class="line">          type: &#39;warning&#39;</span><br><span class="line"></span><br><span class="line">        &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">          store.dispatch(&#39;user&#x2F;resetToken&#39;).then(() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">            location.reload()</span><br><span class="line"></span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return Promise.reject(new Error(res.message || &#39;Error&#39;))</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      return res</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  error &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#39;err&#39; + error) &#x2F;&#x2F; for debug</span><br><span class="line"></span><br><span class="line">    Message(&#123;</span><br><span class="line"></span><br><span class="line">      message: error.message,</span><br><span class="line"></span><br><span class="line">      type: &#39;error&#39;,</span><br><span class="line"></span><br><span class="line">      duration: 5 * 1000</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return Promise.reject(error)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">export default service</span><br></pre></td></tr></table></figure></li><li><p>新建index.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import request from &#39;@&#x2F;utils&#x2F;request&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export function fetchList(query) &#123;</span><br><span class="line"></span><br><span class="line">  return request(&#123;</span><br><span class="line"></span><br><span class="line">    url: &#39;&#x2F;vue-element-admin&#x2F;article&#x2F;list&#39;, &#x2F;&#x2F; 可进行地址的拼接</span><br><span class="line"></span><br><span class="line">    method: &#39;get&#39;,</span><br><span class="line"></span><br><span class="line">    params: query，</span><br><span class="line"></span><br><span class="line">    baseURL: &#39;xxxx&#39;  &#x2F;&#x2F; 可进行覆盖url</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用与上部分一样</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是测试文章封面图的文章</title>
      <link href="/2020/05/28/%E8%BF%99%E6%98%AF%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%9A%84%E6%96%87%E7%AB%A0/"/>
      <url>/2020/05/28/%E8%BF%99%E6%98%AF%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%9A%84%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>笔记摘录</title>
      <link href="/2020/05/27/%E7%AC%94%E8%AE%B0%E6%91%98%E5%BD%95/"/>
      <url>/2020/05/27/%E7%AC%94%E8%AE%B0%E6%91%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="这是我的笔记摘录"><a href="#这是我的笔记摘录" class="headerlink" title="这是我的笔记摘录"></a>这是我的笔记摘录</h3><ul><li>关于第一点1</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础面试题</title>
      <link href="/2020/05/27/test/"/>
      <url>/2020/05/27/test/</url>
      
        <content type="html"><![CDATA[<h3 id="html常见面试题"><a href="#html常见面试题" class="headerlink" title="html常见面试题"></a>html常见面试题</h3><ol><li><p>DOCTYPE 有什么作用？怎么写？<br> DOCTYPE 是document type的简写，它并不是HTML标签，也没有结束标签，它是一种标记语言的文档类型声明，即告诉浏览器当前HTML是用什么版本编写的。DOCTYPE的声明必须是HTML文档的第一行，位于html标签的第一行，位于html标签之前。在遵守html的规则前提下，这是必需的元素。否则会影响代码验证，并决定了浏览器如何显示你的web文档。</p><a id="more"></a></li><li><p>列出常见的标签，并简单介绍这些标签用在什么场景？</p><ul><li>&lt; html &gt;</li><li>&lt; body &gt;</li><li>&lt; title &gt;</li><li>&lt; a &gt; <ul><li>herf：创建指向另一个文档的链接。</li><li>target： 定义链接的文档在何处显示,只有herf存在时起效。</li><li>download: 指定下载的链接。</li><li>title: 可以让鼠标悬停在超链接上时，显示该超链接的文字注释。(如果希望注释魏多行，可以使用&amp;#10；作为换行符)</li></ul></li><li>&lt; img &gt;</li><li>&lt; div &gt;</li><li>&lt; ul &gt;</li><li>&lt; li &gt;</li><li>&lt; ol &gt;</li><li>&lt; form &gt;</li><li>&lt; input &gt;</li><li>&lt; textarea &gt;</li><li>&lt; h1 &gt;- &lt; h6 &gt;</li><li>&lt; link &gt;</li><li>&lt; p &gt;</li><li>&lt; span &gt;</li><li>&lt; table &gt;</li><li>&lt; style &gt;</li><li>&lt; button &gt;</li></ul></li><li><p>页面出现了乱码，是怎么回事？如何解决？</p><ul><li>比如网页源代码是gbk的编码，而内容中的文字是utf-8编码的，这样浏览器打开会出现html乱码。反之同理。<ul><li>采用软件进行编辑HTML页面，同时将其编辑内容的编码语言设为需要的。</li></ul></li><li></li></ul></li><li><p>&lt; img &gt;的title 属性和 alt 属性分别有什么作用？</p><ul><li>alt属性是当图片不存在时或者加载失败时的替代文字。</li><li>title属性时对图片的描述与进一步说明。</li><li>搜索引擎对图片意思的判断,主要靠alt属性。所以在图片alt属性中以简要文字说明，同时包含关键词，也是页面优化的一部分。如果需要的话，可以在title中进一步进行说明。</li></ul></li><li><p>HTML 的注释怎样写？</p></li><li><p>HTML5 为什么只写 <!DOCTYPE html> ？</p></li><li><p>data- 属性的作用？</p></li><li><p>Web 标准以及 W3C 标准是什么？</p></li><li><p>DOCTYPE 作用？严格模式与混杂模式如何区分？它们有何意义？</p></li><li><p>HTML 全局属性（Global Attribute）有哪些？</p></li><li><p>怎么从前端进行SEO优化</p><ol><li>合理的网站标题(title),网站描述(description),网站关键字(keyword),这三项中标题的权重最高,关键字的权重最低,描述居中.</li><li>标签语义化：语义化的标签更容易让搜素引擎理解网站页面,所以为了让我们的网站更容易被抓取,尽量使用语义化标签。</li><li>搜索引擎对抓取的内容实际上是有限的,例如百度一般只会抓取前200K的内容，我们在写代码的时候可以将重要的内容放在上面.</li><li>重要的内容不要使用js,我们都知道对于搜索引擎来说,更喜欢html和css,而不会抓取js的输出内容。</li><li>iframe  不使用iframe,耗能高,安全性低，该标签同样不会被搜索引擎抓取。</li><li>图片增加alt标签,这是一个很重要的标签,在网站无法加载图片的时候，会用文字提示代替图片,提高网站的可读性。</li></ol></li><li><p>HTML中隐藏方式</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123; display: none; &#x2F;* 不占据空间，无法点击 *&#x2F; &#125;</span><br><span class="line">&#123; visibility: hidden; &#x2F;* 占据空间，无法点击 *&#x2F; &#125;</span><br><span class="line">&#123; position: absolute; top: -999em; &#x2F;* 不占据空间，无法点击 *&#x2F; &#125;</span><br><span class="line">&#123; position: relative; top: -999em; &#x2F;* 占据空间，无法点击 *&#x2F; &#125;</span><br><span class="line">&#123; position: absolute; visibility: hidden; &#x2F;* 不占据空间，无法点击 *&#x2F; &#125;</span><br><span class="line">&#123; height: 0; overflow: hidden; &#x2F;* 不占据空间，无法点击 *&#x2F; &#125;</span><br><span class="line">&#123; opacity: 0; filter:Alpha(opacity&#x3D;0); &#x2F;* 占据空间，可以点击 *&#x2F; &#125;</span><br><span class="line">&#123; position: absolute; opacity: 0; filter:Alpha(opacity&#x3D;0); &#x2F;* 不占据空间，可以点击 *&#x2F; &#125;</span><br><span class="line">&#123;</span><br><span class="line">    zoom: 0.001;</span><br><span class="line">    -moz-transform: scale(0);</span><br><span class="line">    -webkit-transform: scale(0);</span><br><span class="line">    -o-transform: scale(0);</span><br><span class="line">    transform: scale(0);</span><br><span class="line">&#x2F;* IE6&#x2F;IE7&#x2F;IE9不占据空间，IE8&#x2F;FireFox&#x2F;Chrome&#x2F;Opera占据空间。都无法点击 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    zoom: 0.001;</span><br><span class="line">    -moz-transform: scale(0);</span><br><span class="line">    -webkit-transform: scale(0);</span><br><span class="line">    -o-transform: scale(0);</span><br><span class="line">    transform: scale(0);</span><br><span class="line">&#x2F;* 不占据空间，无法点击 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="13"><li><p>cookie的弊端</p><ol><li>IE6或者更低版本最多20个coookie。</li><li>IE7和之后的版本最多可以有50个cookie。</li><li>Firefox最多50个cookie。</li><li>chrome和Safari没有做硬性要求。</li></ol></li><li><p>CSS中link和@import的区别是？</p><ol><li>link属于HTML标签，而@import是CSS提供的。</li><li>页面被加载的同时，link会被同时加载，而@import引用的CSS会等到页面被加载完再加载；</li><li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题。</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
